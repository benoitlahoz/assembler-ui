{
  "control-button": {
    "dependsOn": [],
    "usedBy": [],
    "files": [
      {
        "name": "ControlButton.vue",
        "path": "registry/new-york/components/control-button/ControlButton.vue",
        "source": "<script setup lang=\"ts\">\nimport type { PrimitiveProps } from 'reka-ui';\nimport type { HTMLAttributes } from 'vue';\nimport type { ControlButtonVariants } from '.';\nimport { Primitive } from 'reka-ui';\nimport { cn } from '@/lib/utils';\nimport { buttonVariants } from '.';\nimport { computed } from 'vue';\n\nexport interface ControlButtonProps extends PrimitiveProps {\n  variant?: ControlButtonVariants['variant'];\n  shape?: ControlButtonVariants['shape'];\n  color?: string;\n  class?: HTMLAttributes['class'];\n}\n\nconst props = withDefaults(defineProps<ControlButtonProps>(), {\n  as: 'button',\n  shape: 'square',\n  variant: 'default',\n});\n\nconst colorStyle = computed(() => {\n  if (!props.color) return {};\n\n  \n  const isVariable = props.color.startsWith('--');\n  const colorValue = isVariable ? `var(${props.color})` : props.color;\n\n  return {\n    '--button-color': colorValue,\n    'background-color':\n      props.variant === 'outline' || props.variant === 'ghost' ? 'transparent' : colorValue,\n    color: props.variant === 'outline' || props.variant === 'ghost' ? colorValue : 'white',\n    'border-color': props.variant === 'outline' ? colorValue : undefined,\n  };\n});\n</script>\n\n<template>\n  <Primitive\n    data-slot=\"button\"\n    :as=\"as\"\n    :as-child=\"asChild\"\n    :class=\"cn(buttonVariants({ variant, shape }), 'w-full h-full', props.class)\"\n    :style=\"colorStyle\"\n  >\n    <slot />\n  </Primitive>\n</template>\n"
      },
      {
        "name": "index.ts",
        "path": "registry/new-york/components/control-button/index.ts",
        "source": "\n\nimport type { VariantProps } from 'class-variance-authority';\nimport { cva } from 'class-variance-authority';\n\nexport { default as ControlButton } from './ControlButton.vue';\n\nexport const buttonVariants = cva(\n  \"aspect-square w-auto h-auto min-w-0 min-h-0 inline-flex items-center justify-center gap-2 whitespace-nowrap text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive\",\n  {\n    variants: {\n      variant: {\n        default: 'shadow-xs hover:brightness-90',\n        outline:\n          'border border-current/20 bg-transparent shadow-xs hover:bg-current/10 dark:border-current/30 dark:hover:bg-current/20',\n        ghost: 'bg-transparent hover:bg-current/10',\n        solid: 'shadow-xs hover:brightness-90',\n      },\n      shape: {\n        square: 'rounded-md',\n        circle: 'rounded-full',\n      },\n    },\n    defaultVariants: {\n      variant: 'default',\n      shape: 'square',\n    },\n  }\n);\n\nexport type ControlButtonVariants = VariantProps<typeof buttonVariants>;\nexport { type ControlButtonProps } from './ControlButton.vue';\n"
      }
    ]
  },
  "control-grid": {
    "dependsOn": [
      {
        "path": "composables/use-drag-drop",
        "files": [
          "useDragDrop.ts"
        ]
      },
      {
        "path": "composables/use-control-registry",
        "files": [
          "useControlRegistry.ts"
        ]
      }
    ],
    "usedBy": [
      "use-control-registry",
      "use-controls-grid"
    ],
    "files": [
      {
        "name": "ControlGrid.old.vue",
        "path": "registry/new-york/components/control-grid/ControlGrid.old.vue",
        "source": "<script setup lang=\"ts\">\nimport { ref, computed, watch, onMounted, onUnmounted, type Component } from 'vue';\nimport { useElementSize, useDropZone } from '@vueuse/core';\nimport { useMotion } from '@vueuse/motion';\n\ninterface GridItem {\n  id: string;\n  x: number; \n  y: number; \n  width: number; \n  height: number; \n  component?: any; \n  color?: string; \n}\n\ninterface ComponentToRegister {\n  name: string; \n  component: Component; \n}\n\ninterface Props {\n  cellSize?: number; \n  gap?: number; \n  minColumns?: number; \n  items?: GridItem[]; \n  showGrid?: boolean; \n  snapToGrid?: boolean; \n  components?: ComponentToRegister[]; \n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  cellSize: 80,\n  gap: 8,\n  minColumns: 4,\n  items: () => [],\n  showGrid: true,\n  snapToGrid: true,\n  components: () => [],\n});\n\nconst emit = defineEmits<{\n  'update:items': [items: GridItem[]];\n  'item-placed': [item: GridItem];\n  'item-moved': [item: GridItem];\n  'item-removed': [id: string];\n}>();\n\n\nconst gridContainer = ref<HTMLElement | null>(null);\nconst placedItems = ref<GridItem[]>([...props.items]);\nconst hoverCell = ref<{ x: number; y: number } | null>(null);\nconst draggedItem = ref<GridItem | null>(null);\nconst draggedFromGrid = ref(false);\nconst previewSize = ref<{ width: number; height: number } | null>(null);\n\n\nconst componentRegistry = ref<Map<string, Component>>(new Map());\n\n\nconst { width: gridWidth, height: gridHeight } = useElementSize(gridContainer);\n\n\nconst columns = computed(() => {\n  const cols = Math.floor(gridWidth.value / (props.cellSize + props.gap));\n  return Math.max(cols, props.minColumns);\n});\n\nconst rows = computed(() => {\n  return Math.max(Math.floor(gridHeight.value / (props.cellSize + props.gap)), 6);\n});\n\nconst gridTemplateColumns = computed(() => {\n  return `repeat(${columns.value}, ${props.cellSize}px)`;\n});\n\nconst gridTemplateRows = computed(() => {\n  return `repeat(${rows.value}, ${props.cellSize}px)`;\n});\n\n\nconst isCellOccupied = (x: number, y: number, excludeId?: string): boolean => {\n  return placedItems.value.some((item) => {\n    if (excludeId && item.id === excludeId) return false;\n    return x >= item.x && x < item.x + item.width && y >= item.y && y < item.y + item.height;\n  });\n};\n\n\nconst isValidPlacement = (\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  excludeId?: string\n): boolean => {\n  \n  if (x < 0 || y < 0 || x + width > columns.value || y + height > rows.value) {\n    return false;\n  }\n\n  \n  for (let dx = 0; dx < width; dx++) {\n    for (let dy = 0; dy < height; dy++) {\n      if (isCellOccupied(x + dx, y + dy, excludeId)) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n};\n\n\nconst findAvailablePosition = (width: number, height: number): { x: number; y: number } | null => {\n  for (let y = 0; y <= rows.value - height; y++) {\n    for (let x = 0; x <= columns.value - width; x++) {\n      if (isValidPlacement(x, y, width, height)) {\n        return { x, y };\n      }\n    }\n  }\n  return null;\n};\n\n\nconst updateGridSize = () => {\n  if (gridContainer.value) {\n    const rect = gridContainer.value.getBoundingClientRect();\n    gridWidth.value = rect.width;\n    gridHeight.value = rect.height;\n  }\n};\n\n\nconst getGridPosition = (clientX: number, clientY: number): { x: number; y: number } => {\n  if (!gridContainer.value) return { x: 0, y: 0 };\n\n  const rect = gridContainer.value.getBoundingClientRect();\n  const relativeX = clientX - rect.left - props.gap; \n  const relativeY = clientY - rect.top - props.gap; \n\n  const x = Math.floor(relativeX / (props.cellSize + props.gap));\n  const y = Math.floor(relativeY / (props.cellSize + props.gap));\n\n  return {\n    x: Math.max(0, Math.min(x, columns.value - 1)),\n    y: Math.max(0, Math.min(y, rows.value - 1)),\n  };\n};\n\n\nconst handleDragStart = (event: DragEvent, item: GridItem, fromGrid = false) => {\n  draggedItem.value = { ...item };\n  draggedFromGrid.value = fromGrid;\n  previewSize.value = { width: item.width, height: item.height };\n\n  if (event.dataTransfer) {\n    event.dataTransfer.effectAllowed = 'move';\n    event.dataTransfer.setData('application/json', JSON.stringify(item));\n  }\n};\n\nconst handleDragOver = (event: DragEvent) => {\n  event.preventDefault();\n\n  \n  if (!draggedItem.value && event.dataTransfer) {\n    \n    const types = event.dataTransfer.types;\n    if (types.includes('application/json')) {\n      \n      \n      previewSize.value = { width: 1, height: 1 };\n    }\n  }\n\n  if (event.dataTransfer) {\n    const effect = event.dataTransfer.effectAllowed;\n    if (effect === 'copy' || effect === 'copyMove') {\n      event.dataTransfer.dropEffect = 'copy';\n    } else {\n      event.dataTransfer.dropEffect = 'move';\n    }\n  }\n\n  const pos = getGridPosition(event.clientX, event.clientY);\n\n  \n  if (draggedItem.value) {\n    const excludeId = draggedFromGrid.value ? draggedItem.value.id : undefined;\n\n    if (\n      isValidPlacement(pos.x, pos.y, draggedItem.value.width, draggedItem.value.height, excludeId)\n    ) {\n      hoverCell.value = pos;\n    } else {\n      hoverCell.value = null;\n      if (event.dataTransfer) {\n        event.dataTransfer.dropEffect = 'none';\n      }\n    }\n  } else if (previewSize.value) {\n    \n    \n    hoverCell.value = pos;\n  }\n};\n\nconst handleDragLeave = (event: DragEvent) => {\n  \n  const relatedTarget = event.relatedTarget as HTMLElement | null;\n  if (!relatedTarget || !gridContainer.value?.contains(relatedTarget)) {\n    hoverCell.value = null;\n    \n  }\n};\n\nconst handleDragEnter = (event: DragEvent) => {\n  event.preventDefault();\n  \n  if (event.dataTransfer) {\n    const effect = event.dataTransfer.effectAllowed;\n    if (effect === 'copy' || effect === 'copyMove') {\n      event.dataTransfer.dropEffect = 'copy';\n    } else {\n      event.dataTransfer.dropEffect = 'move';\n    }\n  }\n};\n\nconst handleDragEnd = () => {\n  draggedItem.value = null;\n  hoverCell.value = null;\n  draggedFromGrid.value = false;\n  previewSize.value = null;\n};\n\nconst handleDrop = (event: DragEvent) => {\n  event.preventDefault();\n\n  let itemToDrop: GridItem | null = draggedItem.value;\n\n  \n  if (!itemToDrop && event.dataTransfer) {\n    try {\n      const data = event.dataTransfer.getData('application/json');\n      if (data) {\n        itemToDrop = JSON.parse(data);\n        \n        if (itemToDrop) {\n          previewSize.value = { width: itemToDrop.width, height: itemToDrop.height };\n        }\n      }\n    } catch (e) {\n      console.error('Erreur lors du parsing des données de drag:', e);\n      draggedItem.value = null;\n      hoverCell.value = null;\n      draggedFromGrid.value = false;\n      previewSize.value = null;\n      return;\n    }\n  }\n\n  if (!itemToDrop || !hoverCell.value) {\n    \n    draggedItem.value = null;\n    hoverCell.value = null;\n    draggedFromGrid.value = false;\n    previewSize.value = null;\n    return;\n  }\n\n  \n  const excludeId = draggedFromGrid.value ? itemToDrop.id : undefined;\n  if (\n    !isValidPlacement(\n      hoverCell.value.x,\n      hoverCell.value.y,\n      itemToDrop.width,\n      itemToDrop.height,\n      excludeId\n    )\n  ) {\n    console.warn('Placement invalide');\n    draggedItem.value = null;\n    hoverCell.value = null;\n    draggedFromGrid.value = false;\n    previewSize.value = null;\n    return;\n  }\n\n  const newItem: GridItem = {\n    ...itemToDrop,\n    x: hoverCell.value.x,\n    y: hoverCell.value.y,\n  };\n\n  if (draggedFromGrid.value) {\n    \n    const index = placedItems.value.findIndex((item) => item.id === newItem.id);\n    if (index !== -1) {\n      placedItems.value[index] = newItem;\n      emit('item-moved', newItem);\n    }\n  } else {\n    \n    placedItems.value.push(newItem);\n    emit('item-placed', newItem);\n  }\n\n  emit('update:items', placedItems.value);\n\n  draggedItem.value = null;\n  hoverCell.value = null;\n  draggedFromGrid.value = false;\n  previewSize.value = null;\n};\n\nconst removeItem = (id: string) => {\n  const index = placedItems.value.findIndex((item) => item.id === id);\n  if (index !== -1) {\n    placedItems.value.splice(index, 1);\n    emit('item-removed', id);\n    emit('update:items', placedItems.value);\n  }\n};\n\n\nconst getComponent = (name: string): Component | undefined => {\n  return componentRegistry.value.get(name);\n};\n\n\nlet resizeObserver: ResizeObserver | null = null;\n\nonMounted(() => {\n  \n  props.components.forEach(({ name, component }) => {\n    componentRegistry.value.set(name, component);\n  });\n\n  updateGridSize();\n\n  if (gridContainer.value) {\n    resizeObserver = new ResizeObserver(() => {\n      updateGridSize();\n    });\n    resizeObserver.observe(gridContainer.value);\n  }\n});\n\n\nwatch(\n  () => props.components,\n  (newComponents) => {\n    componentRegistry.value.clear();\n    newComponents.forEach(({ name, component }) => {\n      componentRegistry.value.set(name, component);\n    });\n  },\n  { deep: true }\n);\n\nonUnmounted(() => {\n  if (resizeObserver && gridContainer.value) {\n    resizeObserver.unobserve(gridContainer.value);\n  }\n});\n\n\ndefineExpose({\n  addItem: (item: Omit<GridItem, 'x' | 'y'>) => {\n    const position = findAvailablePosition(item.width, item.height);\n    if (position) {\n      const newItem: GridItem = { ...item, ...position } as GridItem;\n      placedItems.value.push(newItem);\n      emit('item-placed', newItem);\n      emit('update:items', placedItems.value);\n      return newItem;\n    }\n    return null;\n  },\n  addItemByComponent: (\n    componentName: string,\n    width: number = 1,\n    height: number = 1,\n    additionalProps?: Record<string, any>\n  ) => {\n    const component = getComponent(componentName);\n    if (!component) {\n      console.warn(`Composant \"${componentName}\" non trouvé dans le registre`);\n      return null;\n    }\n\n    const position = findAvailablePosition(width, height);\n    if (position) {\n      const newItem: GridItem = {\n        id: `${componentName}-${Date.now()}`,\n        x: position.x,\n        y: position.y,\n        width,\n        height,\n        component,\n        ...additionalProps,\n      };\n      placedItems.value.push(newItem);\n      emit('item-placed', newItem);\n      emit('update:items', placedItems.value);\n      return newItem;\n    }\n    return null;\n  },\n  removeItem,\n  clearGrid: () => {\n    placedItems.value = [];\n    emit('update:items', []);\n  },\n  getComponent,\n  getRegisteredComponents: () => Array.from(componentRegistry.value.keys()),\n});\n</script>\n\n<template>\n  <div class=\"controls-grid-container flex gap-4 w-full h-full\">\n    \n    <slot\n      name=\"toolbar\"\n      :columns=\"columns\"\n      :rows=\"rows\"\n      :placed-items=\"placedItems\"\n      :component-registry=\"componentRegistry\"\n      :get-component=\"getComponent\"\n      :get-registered-components=\"() => Array.from(componentRegistry.keys())\"\n    />\n\n    \n    <div\n      ref=\"gridContainer\"\n      class=\"relative w-full h-full min-h-[400px] overflow-auto bg-transparent border border-border rounded flex-1\"\n      :style=\"{\n        '--cell-size': `${cellSize}px`,\n        '--gap-size': `${gap}px`,\n      }\"\n      @dragenter=\"handleDragEnter\"\n      @dragover=\"handleDragOver\"\n      @dragleave=\"handleDragLeave\"\n      @drop=\"handleDrop\"\n    >\n      \n      <div\n        class=\"relative grid z-1\"\n        :style=\"{\n          gridTemplateColumns,\n          gridTemplateRows,\n          gap: `${gap}px`,\n          padding: `${gap}px`,\n        }\"\n      >\n        \n        <div\n          v-if=\"hoverCell && (draggedItem || previewSize)\"\n          class=\"bg-primary/10 border-2 border-dashed border-primary rounded-lg pointer-events-none animate-pulse-subtle\"\n          v-motion\n          :initial=\"{ opacity: 0, scale: 0.95 }\"\n          :enter=\"{ opacity: 1, scale: 1, transition: { duration: 150 } }\"\n          :style=\"{\n            gridColumn: `${hoverCell.x + 1} / span ${draggedItem?.width || previewSize?.width || 1}`,\n            gridRow: `${hoverCell.y + 1} / span ${draggedItem?.height || previewSize?.height || 1}`,\n          }\"\n        />\n\n        <div\n          v-for=\"item in placedItems\"\n          :key=\"item.id\"\n          class=\"grid-item-wrapper relative cursor-move select-none transition-all duration-200 hover:-translate-y-0.5 hover:shadow-lg active:cursor-grabbing active:opacity-70\"\n          :draggable=\"true\"\n          :style=\"{\n            gridColumn: `${item.x + 1} / span ${item.width}`,\n            gridRow: `${item.y + 1} / span ${item.height}`,\n          }\"\n          v-motion\n          :initial=\"{ opacity: 0, scale: 0.8 }\"\n          :enter=\"{\n            opacity: 1,\n            scale: 1,\n            transition: { type: 'spring', stiffness: 300, damping: 20 },\n          }\"\n          @dragstart.stop=\"handleDragStart($event, item, true)\"\n          @dragend.stop=\"handleDragEnd\"\n        >\n          <div\n            class=\"relative w-full h-full bg-card/50 border border-border rounded overflow-hidden flex flex-col\"\n            draggable=\"false\"\n          >\n            <button\n              class=\"grid-item-remove absolute top-1 right-1 z-10 flex items-center justify-center w-6 h-6 bg-destructive text-destructive-foreground border-none rounded cursor-pointer opacity-0 transition-all duration-200 scale-75 hover:bg-destructive/90 hover:scale-110 active:scale-95\"\n              @click.stop=\"removeItem(item.id)\"\n              aria-label=\"Supprimer\"\n            >\n              <svg\n                xmlns=\"http://www.w3.org/2000/svg\"\n                width=\"16\"\n                height=\"16\"\n                viewBox=\"0 0 24 24\"\n                fill=\"none\"\n                stroke=\"currentColor\"\n                stroke-width=\"2\"\n                stroke-linecap=\"round\"\n                stroke-linejoin=\"round\"\n              >\n                <path d=\"M18 6 6 18\" />\n                <path d=\"m6 6 12 12\" />\n              </svg>\n            </button>\n\n            <div class=\"flex-1 p-2 flex items-center justify-center overflow-hidden\">\n              <component v-if=\"item.component\" :is=\"item.component\" v-bind=\"item\" />\n              <div\n                v-else\n                class=\"flex flex-col items-center justify-center gap-2 w-full h-full text-muted-foreground\"\n              >\n                <span class=\"text-sm\">{{ item.id }}</span>\n                <span class=\"text-xs\"> {{ item.width }}x{{ item.height }} </span>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      \n      <slot :columns=\"columns\" :rows=\"rows\" :placed-items=\"placedItems\" />\n    </div>\n  </div>\n</template>\n\n<style scoped>\n@keyframes pulse-subtle {\n  0%,\n  100% {\n    opacity: 0.5;\n  }\n  50% {\n    opacity: 0.8;\n  }\n}\n\n.animate-pulse-subtle {\n  animation: pulse-subtle 1.5s ease-in-out infinite;\n}\n\n\n.grid-item-wrapper:hover .grid-item-remove {\n  opacity: 1 !important;\n  transform: scale(1) !important;\n}\n</style>\n"
      },
      {
        "name": "ControlGrid.vue",
        "path": "registry/new-york/components/control-grid/ControlGrid.vue",
        "source": "<script setup lang=\"ts\">\n\n\nimport { provide, watch, onMounted, computed, ref, nextTick, type Ref } from 'vue';\nimport { useElementSize, useElementBounding, useMouse, useEventListener } from '@vueuse/core';\nimport { useMotion } from '@vueuse/motion';\nimport {\n  useDragDrop,\n  DragDropUtils,\n  type DragDropItem,\n} from '../../composables/use-drag-drop/useDragDrop';\nimport {\n  ControlGridItemsKey,\n  ControlGridConfigKey,\n  ControlGridHoverKey,\n  ControlGridDragStateKey,\n  ControlGridComponentRegistryKey,\n  ControlGridAddItemKey,\n  ControlGridAddItemByComponentKey,\n  ControlGridRemoveItemKey,\n  ControlGridClearGridKey,\n  ControlGridGetComponentKey,\n  ControlGridGetRegisteredComponentsKey,\n  type GridItem,\n  type GridConfig,\n  type GridPosition,\n  type DragState,\n  type ComponentToRegister,\n  GridUtils,\n} from '.';\n\n\nconst isClient = typeof window !== 'undefined';\n\nexport interface ControlGridProps {\n  \n  cellSize?: number;\n  \n  gap?: number;\n  \n  minColumns?: number;\n  \n  items?: GridItem[];\n  \n  showGrid?: boolean;\n  \n  snapToGrid?: boolean;\n  \n  components?: ComponentToRegister[];\n}\n\nconst props = withDefaults(defineProps<ControlGridProps>(), {\n  cellSize: 80,\n  gap: 8,\n  minColumns: 4,\n  items: () => [],\n  showGrid: true,\n  snapToGrid: true,\n  components: () => [],\n});\n\nconst emit = defineEmits<{\n  'update:items': [items: GridItem[]];\n  'item-placed': [item: GridItem];\n  'item-moved': [item: GridItem];\n  'item-removed': [id: string];\n  'config-changed': [config: GridConfig];\n}>();\n\n\nconst gridContainer = ref<HTMLElement | null>(null);\nconst placedItems = ref<GridItem[]>([...props.items]);\nconst hoverCell = ref<GridPosition | null>(null);\nconst previewSize = ref<{ width: number; height: number } | null>(null);\n\n\nconst itemRefs = ref<Map<string, HTMLElement>>(new Map());\n\n\nconst componentRegistry = ref<Map<string, any>>(new Map());\n\n\nconst { width: gridWidth, height: gridHeight } = useElementSize(gridContainer);\nconst gridBounds = useElementBounding(gridContainer);\nconst { x: mouseX, y: mouseY } = useMouse();\n\n\nconst {\n  dragState: internalDragState,\n  dragOffset,\n  startDrag,\n  handleDragOver: handleDragOverComposable,\n  endDrag,\n  getVirtualBounds,\n  getItemFromDataTransfer,\n} = useDragDrop<any>({\n  unitSize: props.cellSize,\n  gap: props.gap,\n  validatePlacement: (x, y, width, height, excludeId) => {\n    return isValidPlacement(x, y, width, height, excludeId);\n  },\n});\n\n\nconst dragState = ref<DragState>({\n  item: null,\n  fromGrid: false,\n  hoverPosition: null,\n  isValid: false,\n});\n\n\nwatch(\n  internalDragState,\n  (newState) => {\n    dragState.value = {\n      item: newState.item as GridItem | null,\n      fromGrid: newState.fromContainer,\n      hoverPosition: newState.hoverPosition,\n      isValid: newState.isValid,\n    };\n  },\n  { deep: true }\n);\n\n\nconst previewRef = ref<HTMLElement | null>(null);\n\n\nconst itemVariants = {\n  initial: {\n    scale: 1,\n    opacity: 1,\n  },\n  placed: {\n    scale: [0.95, 1.05, 1],\n    transition: {\n      type: 'spring',\n      stiffness: 300,\n      damping: 25,\n      duration: 400,\n    },\n  },\n  hover: {\n    scale: 1.02,\n    y: -2,\n    transition: {\n      type: 'spring',\n      stiffness: 400,\n      damping: 30,\n    },\n  },\n  dragging: {\n    scale: 1.05,\n    opacity: 0.7,\n    transition: {\n      type: 'spring',\n      stiffness: 300,\n      damping: 20,\n    },\n  },\n};\n\n\nconst previewVariants = {\n  initial: {\n    scale: 0.9,\n    opacity: 0,\n  },\n  enter: {\n    scale: 1,\n    opacity: 1,\n    transition: {\n      type: 'spring',\n      stiffness: 400,\n      damping: 30,\n      duration: 150,\n    },\n  },\n  invalid: {\n    scale: [1, 0.95, 1],\n    borderColor: ['rgba(239, 68, 68, 0.5)', 'rgba(239, 68, 68, 0.8)', 'rgba(239, 68, 68, 0.5)'],\n    transition: {\n      repeat: Infinity,\n      duration: 1000,\n    },\n  },\n};\n\n\nconst gridConfig = computed<GridConfig>(() => {\n  const cols = Math.floor(gridWidth.value / (props.cellSize + props.gap));\n  const calculatedColumns = Math.max(cols, props.minColumns);\n  const calculatedRows = Math.max(Math.floor(gridHeight.value / (props.cellSize + props.gap)), 6);\n\n  return {\n    cellSize: props.cellSize,\n    gap: props.gap,\n    columns: calculatedColumns,\n    rows: calculatedRows,\n    width: gridWidth.value,\n    height: gridHeight.value,\n  };\n});\n\n\nconst columns = computed(() => gridConfig.value.columns);\nconst rows = computed(() => gridConfig.value.rows);\n\nconst gridTemplateColumns = computed(() => {\n  return `repeat(${columns.value}, ${props.cellSize}px)`;\n});\n\nconst gridTemplateRows = computed(() => {\n  return `repeat(${rows.value}, ${props.cellSize}px)`;\n});\n\n\nconst isCellOccupied = (x: number, y: number, excludeId?: string): boolean => {\n  return placedItems.value.some((item) => {\n    if (excludeId && item.id === excludeId) return false;\n    return x >= item.x && x < item.x + item.width && y >= item.y && y < item.y + item.height;\n  });\n};\n\nconst isValidPlacement = (\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  excludeId?: string\n): boolean => {\n  \n  if (x < 0 || y < 0 || x + width > columns.value || y + height > rows.value) {\n    return false;\n  }\n\n  \n  for (let dx = 0; dx < width; dx++) {\n    for (let dy = 0; dy < height; dy++) {\n      if (isCellOccupied(x + dx, y + dy, excludeId)) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n};\n\nconst findAvailablePosition = (width: number, height: number): { x: number; y: number } | null => {\n  for (let y = 0; y <= rows.value - height; y++) {\n    for (let x = 0; x <= columns.value - width; x++) {\n      if (isValidPlacement(x, y, width, height)) {\n        return { x, y };\n      }\n    }\n  }\n  return null;\n};\n\n\nconst getGridPositionByIntersection = (elementBounds: {\n  left: number;\n  top: number;\n  right: number;\n  bottom: number;\n  width: number;\n  height: number;\n}): { x: number; y: number } | null => {\n  if (!gridContainer.value) return null;\n\n  let maxIntersectionArea = 0;\n  let bestPosition = { x: 0, y: 0 };\n\n  \n  const startX = Math.max(\n    0,\n    Math.floor(\n      (elementBounds.left - gridBounds.left.value - props.gap) / (props.cellSize + props.gap)\n    )\n  );\n  const endX = Math.min(\n    columns.value - 1,\n    Math.ceil(\n      (elementBounds.right - gridBounds.left.value - props.gap) / (props.cellSize + props.gap)\n    )\n  );\n  const startY = Math.max(\n    0,\n    Math.floor(\n      (elementBounds.top - gridBounds.top.value - props.gap) / (props.cellSize + props.gap)\n    )\n  );\n  const endY = Math.min(\n    rows.value - 1,\n    Math.ceil(\n      (elementBounds.bottom - gridBounds.top.value - props.gap) / (props.cellSize + props.gap)\n    )\n  );\n\n  for (let y = startY; y <= endY; y++) {\n    for (let x = startX; x <= endX; x++) {\n      \n      const cellLeft = gridBounds.left.value + props.gap + x * (props.cellSize + props.gap);\n      const cellTop = gridBounds.top.value + props.gap + y * (props.cellSize + props.gap);\n      const cellRight = cellLeft + props.cellSize;\n      const cellBottom = cellTop + props.cellSize;\n\n      \n      const intersectionLeft = Math.max(elementBounds.left, cellLeft);\n      const intersectionTop = Math.max(elementBounds.top, cellTop);\n      const intersectionRight = Math.min(elementBounds.right, cellRight);\n      const intersectionBottom = Math.min(elementBounds.bottom, cellBottom);\n\n      \n      const intersectionWidth = Math.max(0, intersectionRight - intersectionLeft);\n      const intersectionHeight = Math.max(0, intersectionBottom - intersectionTop);\n      const intersectionArea = intersectionWidth * intersectionHeight;\n\n      if (intersectionArea > maxIntersectionArea) {\n        maxIntersectionArea = intersectionArea;\n        bestPosition = { x, y };\n      }\n    }\n  }\n\n  \n  return maxIntersectionArea > 0 ? bestPosition : null;\n};\n\nconst getGridPosition = (clientX: number, clientY: number): { x: number; y: number } => {\n  if (!gridContainer.value) return { x: 0, y: 0 };\n\n  const relativeX = clientX - gridBounds.left.value - props.gap;\n  const relativeY = clientY - gridBounds.top.value - props.gap;\n\n  const x = Math.floor(relativeX / (props.cellSize + props.gap));\n  const y = Math.floor(relativeY / (props.cellSize + props.gap));\n\n  return {\n    x: Math.max(0, Math.min(x, columns.value - 1)),\n    y: Math.max(0, Math.min(y, rows.value - 1)),\n  };\n};\n\n\nconst addItem = (item: Omit<GridItem, 'x' | 'y'>): GridItem | null => {\n  const position = findAvailablePosition(item.width, item.height);\n  if (position) {\n    const newItem: GridItem = { ...item, ...position } as GridItem;\n    placedItems.value.push(newItem);\n\n    \n    if (isClient) {\n      nextTick(() => {\n        const el = itemRefs.value.get(newItem.id);\n        if (el) {\n          const motion = useMotion(el, itemVariants);\n          motion.apply('placed');\n        }\n      });\n    }\n\n    emit('item-placed', newItem);\n    emit('update:items', placedItems.value);\n    return newItem;\n  }\n  return null;\n};\n\nconst addItemByComponent = (\n  componentName: string,\n  width: number = 1,\n  height: number = 1,\n  additionalProps?: Record<string, any>\n): GridItem | null => {\n  const component = getComponent(componentName);\n  if (!component) {\n    console.warn(`Composant \"${componentName}\" non trouvé dans le registre`);\n    return null;\n  }\n\n  const position = findAvailablePosition(width, height);\n  if (position) {\n    const newItem: GridItem = {\n      id: `${componentName}-${Date.now()}`,\n      x: position.x,\n      y: position.y,\n      width,\n      height,\n      component,\n      ...additionalProps,\n    };\n    placedItems.value.push(newItem);\n    emit('item-placed', newItem);\n    emit('update:items', placedItems.value);\n    return newItem;\n  }\n  return null;\n};\n\nconst removeItem = (id: string): void => {\n  const index = placedItems.value.findIndex((item) => item.id === id);\n  if (index !== -1) {\n    placedItems.value.splice(index, 1);\n    emit('item-removed', id);\n    emit('update:items', placedItems.value);\n  }\n};\n\nconst clearGrid = (): void => {\n  placedItems.value = [];\n  emit('update:items', []);\n};\n\nconst getComponent = (name: string): any | undefined => {\n  return componentRegistry.value.get(name);\n};\n\nconst getRegisteredComponents = (): string[] => {\n  return Array.from(componentRegistry.value.keys());\n};\n\n\nconst handleDragStart = (event: DragEvent, item: GridItem, fromGrid = false) => {\n  previewSize.value = { width: item.width, height: item.height };\n  startDrag(event, item, fromGrid);\n};\n\nconst handleDragOver = (event: DragEvent) => {\n  \n  const containerBounds = {\n    left: gridBounds.left.value,\n    top: gridBounds.top.value,\n    right: gridBounds.right.value,\n    bottom: gridBounds.bottom.value,\n    width: gridBounds.width.value,\n    height: gridBounds.height.value,\n  };\n\n  const pos = handleDragOverComposable(event, containerBounds, (virtualBounds) => {\n    return DragDropUtils.getPositionByIntersection(\n      virtualBounds,\n      containerBounds,\n      props.cellSize,\n      props.gap,\n      columns.value,\n      rows.value\n    );\n  });\n\n  \n  hoverCell.value = pos;\n\n  \n  if (!dragState.value.item && event.dataTransfer) {\n    const types = event.dataTransfer.types;\n    if (types.includes('application/json')) {\n      previewSize.value = { width: 1, height: 1 };\n    }\n  }\n};\n\nconst handleDragLeave = (event: DragEvent) => {\n  if (!dragState.value) return;\n\n  const relatedTarget = event.relatedTarget as HTMLElement | null;\n  if (!relatedTarget || !gridContainer.value?.contains(relatedTarget)) {\n    hoverCell.value = null;\n    dragState.value.hoverPosition = null;\n  }\n};\n\nconst handleDragEnter = (event: DragEvent) => {\n  event.preventDefault();\n  if (event.dataTransfer) {\n    const effect = event.dataTransfer.effectAllowed;\n    if (effect === 'copy' || effect === 'copyMove') {\n      event.dataTransfer.dropEffect = 'copy';\n    } else {\n      event.dataTransfer.dropEffect = 'move';\n    }\n  }\n};\n\nconst handleDragEnd = () => {\n  hoverCell.value = null;\n  previewSize.value = null;\n  endDrag();\n};\n\nconst handleDrop = (event: DragEvent) => {\n  event.preventDefault();\n\n  if (!dragState.value) {\n    console.warn('dragState is not initialized');\n    return;\n  }\n\n  let itemToDrop: GridItem | null = dragState.value.item ?? null;\n\n  if (!itemToDrop && event.dataTransfer) {\n    try {\n      const data = event.dataTransfer.getData('application/json');\n      if (data) {\n        itemToDrop = JSON.parse(data);\n        if (itemToDrop) {\n          previewSize.value = { width: itemToDrop.width, height: itemToDrop.height };\n        }\n      }\n    } catch (e) {\n      console.error('Erreur lors du parsing des données de drag:', e);\n      handleDragEnd();\n      return;\n    }\n  }\n\n  if (!itemToDrop || !hoverCell.value) {\n    handleDragEnd();\n    return;\n  }\n\n  const excludeId = dragState.value?.fromGrid ? itemToDrop.id : undefined;\n  if (\n    !isValidPlacement(\n      hoverCell.value.x,\n      hoverCell.value.y,\n      itemToDrop.width,\n      itemToDrop.height,\n      excludeId\n    )\n  ) {\n    console.warn('Placement invalide');\n    handleDragEnd();\n    return;\n  }\n\n  const newItem: GridItem = {\n    ...itemToDrop,\n    x: hoverCell.value.x,\n    y: hoverCell.value.y,\n  };\n\n  if (dragState.value?.fromGrid) {\n    const index = placedItems.value.findIndex((item) => item.id === newItem.id);\n    if (index !== -1) {\n      placedItems.value[index] = newItem;\n\n      \n      if (isClient) {\n        nextTick(() => {\n          const el = itemRefs.value.get(newItem.id);\n          if (el) {\n            const motion = useMotion(el, itemVariants);\n            motion.apply('placed');\n          }\n        });\n      }\n\n      emit('item-moved', newItem);\n    }\n  } else {\n    placedItems.value.push(newItem);\n\n    \n    if (isClient) {\n      nextTick(() => {\n        const el = itemRefs.value.get(newItem.id);\n        if (el) {\n          const motion = useMotion(el, itemVariants);\n          motion.apply('placed');\n        }\n      });\n    }\n\n    emit('item-placed', newItem);\n  }\n\n  emit('update:items', placedItems.value);\n  handleDragEnd();\n};\n\n\n\n\nprovide<Ref<GridItem[]>>(ControlGridItemsKey, placedItems);\n\n\nprovide<Ref<GridConfig>>(ControlGridConfigKey, gridConfig);\n\n\nprovide<Ref<GridPosition | null>>(ControlGridHoverKey, hoverCell);\n\n\nprovide<Ref<DragState>>(ControlGridDragStateKey, dragState);\n\n\nprovide<Ref<Map<string, any>>>(ControlGridComponentRegistryKey, componentRegistry);\n\n\nprovide(ControlGridAddItemKey, addItem);\nprovide(ControlGridAddItemByComponentKey, addItemByComponent);\nprovide(ControlGridRemoveItemKey, removeItem);\nprovide(ControlGridClearGridKey, clearGrid);\nprovide(ControlGridGetComponentKey, getComponent);\nprovide(ControlGridGetRegisteredComponentsKey, getRegisteredComponents);\n\n\nwatch(\n  () => props.items,\n  (newItems) => {\n    placedItems.value = [...newItems];\n  },\n  { deep: true }\n);\n\nwatch(\n  () => props.components,\n  (newComponents) => {\n    componentRegistry.value.clear();\n    newComponents.forEach(({ name, component }) => {\n      componentRegistry.value.set(name, component);\n    });\n  },\n  { deep: true, immediate: true }\n);\n\nwatch(\n  gridConfig,\n  (newConfig) => {\n    emit('config-changed', newConfig);\n  },\n  { deep: true }\n);\n\n\nonMounted(() => {\n  \n  props.components.forEach(({ name, component }) => {\n    componentRegistry.value.set(name, component);\n  });\n});\n\n\ndefineExpose({\n  addItem,\n  addItemByComponent,\n  removeItem,\n  clearGrid,\n  getComponent,\n  getRegisteredComponents,\n  isCellOccupied,\n  isValidPlacement,\n  findAvailablePosition,\n});\n</script>\n\n<template>\n  <div class=\"controls-grid-container flex gap-4 w-full h-full\">\n    \n    <slot\n      name=\"toolbar\"\n      :columns=\"columns\"\n      :rows=\"rows\"\n      :placed-items=\"placedItems\"\n      :component-registry=\"componentRegistry\"\n      :get-component=\"getComponent\"\n      :get-registered-components=\"getRegisteredComponents\"\n      :add-item=\"addItem\"\n      :add-item-by-component=\"addItemByComponent\"\n      :remove-item=\"removeItem\"\n      :clear-grid=\"clearGrid\"\n      :config=\"gridConfig\"\n      :hover-position=\"hoverCell\"\n      :drag-state=\"dragState\"\n    />\n\n    \n    <div\n      ref=\"gridContainer\"\n      class=\"relative w-full h-full min-h-[400px] overflow-auto bg-transparent border border-border rounded flex-1\"\n      :style=\"{\n        '--cell-size': `${cellSize}px`,\n        '--gap-size': `${gap}px`,\n      }\"\n      @dragenter=\"handleDragEnter\"\n      @dragover=\"handleDragOver\"\n      @dragleave=\"handleDragLeave\"\n      @drop=\"handleDrop\"\n    >\n      \n      <div\n        class=\"relative grid z-1\"\n        :style=\"{\n          gridTemplateColumns,\n          gridTemplateRows,\n          gap: `${gap}px`,\n          padding: `${gap}px`,\n        }\"\n      >\n        \n        <div\n          v-if=\"hoverCell && (dragState.item || previewSize)\"\n          ref=\"previewRef\"\n          :class=\"[\n            'rounded-lg pointer-events-none transition-all duration-200',\n            dragState.isValid\n              ? 'bg-primary/10 border-2 border-dashed border-primary animate-fade-in'\n              : 'bg-destructive/10 border-2 border-dashed border-destructive animate-pulse',\n          ]\"\n          :style=\"{\n            gridColumn: `${hoverCell.x + 1} / span ${dragState.item?.width || previewSize?.width || 1}`,\n            gridRow: `${hoverCell.y + 1} / span ${dragState.item?.height || previewSize?.height || 1}`,\n          }\"\n        />\n\n        <div\n          v-for=\"item in placedItems\"\n          :key=\"item.id\"\n          :ref=\"(el) => el && itemRefs.set(item.id, el as HTMLElement)\"\n          class=\"grid-item-wrapper relative cursor-move select-none transition-all duration-200 hover:scale-[1.02] hover:-translate-y-0.5 hover:shadow-lg active:cursor-grabbing active:scale-105 active:opacity-70\"\n          :draggable=\"true\"\n          :style=\"{\n            gridColumn: `${item.x + 1} / span ${item.width}`,\n            gridRow: `${item.y + 1} / span ${item.height}`,\n          }\"\n          @dragstart.stop=\"handleDragStart($event, item, true)\"\n          @dragend.stop=\"handleDragEnd\"\n        >\n          <div\n            class=\"relative w-full h-full bg-card/50 border border-border rounded overflow-hidden flex flex-col\"\n            draggable=\"false\"\n          >\n            <button\n              class=\"grid-item-remove absolute top-1 right-1 z-10 flex items-center justify-center w-6 h-6 bg-destructive text-destructive-foreground border-none rounded cursor-pointer opacity-0 transition-all duration-200 scale-75 hover:bg-destructive/90 hover:scale-110 active:scale-95\"\n              @click.stop=\"removeItem(item.id)\"\n              aria-label=\"Supprimer\"\n            >\n              <svg\n                xmlns=\"http://www.w3.org/2000/svg\"\n                width=\"16\"\n                height=\"16\"\n                viewBox=\"0 0 24 24\"\n                fill=\"none\"\n                stroke=\"currentColor\"\n                stroke-width=\"2\"\n                stroke-linecap=\"round\"\n                stroke-linejoin=\"round\"\n              >\n                <path d=\"M18 6 6 18\" />\n                <path d=\"m6 6 12 12\" />\n              </svg>\n            </button>\n\n            <div class=\"flex-1 p-2 flex items-center justify-center overflow-hidden\">\n              <component v-if=\"item.component\" :is=\"item.component\" v-bind=\"item\" />\n              <div\n                v-else\n                class=\"flex flex-col items-center justify-center gap-2 w-full h-full text-muted-foreground\"\n              >\n                <span class=\"text-sm\">{{ item.id }}</span>\n                <span class=\"text-xs\"> {{ item.width }}x{{ item.height }} </span>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      \n      <slot\n        :columns=\"columns\"\n        :rows=\"rows\"\n        :placed-items=\"placedItems\"\n        :add-item=\"addItem\"\n        :add-item-by-component=\"addItemByComponent\"\n        :remove-item=\"removeItem\"\n        :clear-grid=\"clearGrid\"\n        :get-component=\"getComponent\"\n        :get-registered-components=\"getRegisteredComponents\"\n        :config=\"gridConfig\"\n        :hover-position=\"hoverCell\"\n        :drag-state=\"dragState\"\n      />\n    </div>\n  </div>\n</template>\n\n<style scoped>\n@keyframes fade-in {\n  from {\n    opacity: 0;\n    transform: scale(0.95);\n  }\n  to {\n    opacity: 1;\n    transform: scale(1);\n  }\n}\n\n.animate-fade-in {\n  animation: fade-in 200ms ease-out;\n}\n\n.grid-item-wrapper:active {\n  cursor: grabbing;\n}\n\n\n.grid-item-wrapper:hover .grid-item-remove {\n  opacity: 1 !important;\n  transform: scale(1) !important;\n}\n</style>\n"
      },
      {
        "name": "ControlGridItem.vue",
        "path": "registry/new-york/components/control-grid/ControlGridItem.vue",
        "source": "<script setup lang=\"ts\">\n\n\nimport { inject, computed, type Ref } from 'vue';\nimport {\n  ControlGridItemsKey,\n  ControlGridConfigKey,\n  ControlGridHoverKey,\n  ControlGridDragStateKey,\n  ControlGridAddItemKey,\n  ControlGridRemoveItemKey,\n  ControlGridClearGridKey,\n  type GridItem,\n  type GridConfig,\n  type GridPosition,\n  type DragState,\n} from '.';\n\n\nconst items = inject(ControlGridItemsKey) as Ref<GridItem[]> | undefined;\nconst config = inject(ControlGridConfigKey) as Ref<GridConfig> | undefined;\nconst hoverPosition = inject(ControlGridHoverKey) as Ref<GridPosition | null> | undefined;\nconst dragState = inject(ControlGridDragStateKey) as Ref<DragState> | undefined;\n\n\nconst addItem = inject(ControlGridAddItemKey);\nconst removeItem = inject(ControlGridRemoveItemKey);\nconst clearGrid = inject(ControlGridClearGridKey);\n\n\nconst itemCount = computed(() => items?.value.length || 0);\nconst gridSize = computed(() => {\n  if (!config?.value) return 'N/A';\n  return `${config.value.columns} × ${config.value.rows}`;\n});\n\n\nconst handleAddItem = () => {\n  if (addItem) {\n    addItem({\n      id: `item-${Date.now()}`,\n      width: 1,\n      height: 1,\n    });\n  }\n};\n\nconst handleClearGrid = () => {\n  if (clearGrid) {\n    clearGrid();\n  }\n};\n</script>\n\n<template>\n  <div class=\"controls-grid-child p-4 border border-border rounded-lg\">\n    <h3 class=\"text-lg font-semibold mb-4\">Grid Info (via inject)</h3>\n\n    <div class=\"space-y-2 text-sm\">\n      <div><span class=\"font-medium\">Items:</span> {{ itemCount }}</div>\n      <div><span class=\"font-medium\">Grid Size:</span> {{ gridSize }}</div>\n      <div v-if=\"hoverPosition\">\n        <span class=\"font-medium\">Hover:</span>\n        ({{ hoverPosition.x }}, {{ hoverPosition.y }})\n      </div>\n      <div v-if=\"dragState?.item\">\n        <span class=\"font-medium\">Dragging:</span> {{ dragState.item.id }}\n      </div>\n    </div>\n\n    <div class=\"flex gap-2 mt-4\">\n      <button\n        @click=\"handleAddItem\"\n        class=\"px-3 py-1 bg-primary text-primary-foreground rounded hover:bg-primary/90\"\n      >\n        Add Item\n      </button>\n      <button\n        @click=\"handleClearGrid\"\n        class=\"px-3 py-1 bg-destructive text-destructive-foreground rounded hover:bg-destructive/90\"\n      >\n        Clear Grid\n      </button>\n    </div>\n  </div>\n</template>\n"
      },
      {
        "name": "ControlGridToolbar.vue",
        "path": "registry/new-york/components/control-grid/ControlGridToolbar.vue",
        "source": "<script setup lang=\"ts\">\nimport { ref, computed } from 'vue';\nimport {\n  useControlRegistry,\n  type ControlDefinition,\n} from '../../composables/use-control-registry/useControlRegistry';\n\ninterface Props {\n  \n  category?: string;\n  \n  orientation?: 'horizontal' | 'vertical';\n  \n  itemSize?: number;\n  \n  gap?: number;\n  \n  showLabels?: boolean;\n  \n  labelSize?: 'sm' | 'md' | 'lg';\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  orientation: 'horizontal',\n  itemSize: 60,\n  gap: 8,\n  showLabels: true,\n  labelSize: 'sm',\n});\n\nconst emit = defineEmits<{\n  'control-selected': [control: ControlDefinition];\n  'control-drag-start': [control: ControlDefinition, event: DragEvent];\n}>();\n\nconst { getAllControls, getControlsByCategory } = useControlRegistry();\n\n\nconst controls = computed(() => {\n  if (props.category) {\n    return getControlsByCategory(props.category);\n  }\n  return getAllControls();\n});\n\n\nconst groupedControls = computed(() => {\n  if (props.category) {\n    return { [props.category]: controls.value };\n  }\n\n  const groups: Record<string, ControlDefinition[]> = {};\n  controls.value.forEach((control) => {\n    const category = control.category || 'Autres';\n    if (!groups[category]) {\n      groups[category] = [];\n    }\n    groups[category].push(control);\n  });\n  return groups;\n});\n\n\nconst labelClasses = computed(() => {\n  const sizeClasses = {\n    sm: 'text-xs',\n    md: 'text-sm',\n    lg: 'text-base',\n  };\n  return `${sizeClasses[props.labelSize]} font-medium truncate`;\n});\n\n\nconst handleDragStart = (event: DragEvent, control: ControlDefinition) => {\n  if (!event.dataTransfer) return;\n\n  const dragData = {\n    id: `${control.id}-${Date.now()}`,\n    width: control.defaultSize?.width || 1,\n    height: control.defaultSize?.height || 1,\n    component: control.component,\n    color: control.color,\n    ...control.defaultProps,\n  };\n\n  event.dataTransfer.effectAllowed = 'copy';\n  event.dataTransfer.setData('application/json', JSON.stringify(dragData));\n\n  emit('control-drag-start', control, event);\n};\n\n\nconst handleControlClick = (control: ControlDefinition) => {\n  emit('control-selected', control);\n};\n</script>\n\n<template>\n  <div\n    class=\"controls-toolbar flex bg-card border border-border rounded-lg shadow-sm\"\n    :class=\"{\n      'flex-col overflow-y-auto': orientation === 'vertical',\n      'flex-row overflow-x-auto': orientation === 'horizontal',\n    }\"\n    :style=\"{\n      '--item-size': `${itemSize}px`,\n      '--gap-size': `${gap}px`,\n    }\"\n  >\n    <div\n      v-for=\"(categoryControls, categoryName) in groupedControls\"\n      :key=\"categoryName\"\n      class=\"controls-group\"\n      :class=\"{\n        'flex flex-col': orientation === 'vertical',\n        'flex flex-row': orientation === 'horizontal',\n      }\"\n    >\n      \n      <div\n        v-if=\"!category && Object.keys(groupedControls).length > 1\"\n        class=\"category-header px-3 py-2 text-xs font-semibold text-muted-foreground uppercase tracking-wider bg-muted/50 sticky\"\n        :class=\"{\n          'top-0': orientation === 'vertical',\n          'left-0': orientation === 'horizontal',\n        }\"\n      >\n        {{ categoryName }}\n      </div>\n\n      \n      <div\n        class=\"controls-list flex\"\n        :class=\"{\n          'flex-col': orientation === 'vertical',\n          'flex-row': orientation === 'horizontal',\n        }\"\n        :style=\"{ gap: `${gap}px`, padding: `${gap}px` }\"\n      >\n        <div\n          v-for=\"control in categoryControls\"\n          :key=\"control.id\"\n          class=\"control-item flex cursor-move select-none transition-all duration-200 hover:scale-105 active:cursor-grabbing active:opacity-70\"\n          :class=\"{\n            'flex-col items-center': true,\n            'min-w-(--item-size)': orientation === 'horizontal',\n          }\"\n          :draggable=\"true\"\n          @dragstart=\"handleDragStart($event, control)\"\n          @click=\"handleControlClick(control)\"\n          :title=\"control.description || control.name\"\n        >\n          \n          <div\n            class=\"control-preview relative flex items-center justify-center bg-background border-2 border-border rounded-lg overflow-hidden transition-all duration-200 hover:border-primary hover:shadow-md\"\n            :style=\"{\n              width: `${itemSize}px`,\n              height: `${itemSize}px`,\n              backgroundColor: control.color ? `${control.color}20` : undefined,\n              borderColor: control.color || undefined,\n            }\"\n          >\n            \n            <div\n              v-if=\"control.icon\"\n              class=\"control-icon text-2xl\"\n              :style=\"{ color: control.color }\"\n            >\n              {{ control.icon }}\n            </div>\n\n            \n            <div\n              v-else\n              class=\"control-component-preview w-full h-full flex items-center justify-center p-2 pointer-events-none\"\n            >\n              <component\n                v-if=\"control.component\"\n                :is=\"control.component\"\n                v-bind=\"{ ...control.defaultProps, disabled: true }\"\n                class=\"scale-75 opacity-80\"\n              />\n            </div>\n\n            \n            <div\n              class=\"absolute bottom-1 right-1 px-1.5 py-0.5 text-[10px] font-mono bg-background/90 border border-border rounded\"\n            >\n              {{ control.defaultSize?.width || 1 }}×{{ control.defaultSize?.height || 1 }}\n            </div>\n          </div>\n\n          \n          <span\n            v-if=\"showLabels\"\n            class=\"control-label mt-1 text-center max-w-full\"\n            :class=\"labelClasses\"\n            :style=\"{ maxWidth: `${itemSize}px` }\"\n          >\n            {{ control.name }}\n          </span>\n        </div>\n      </div>\n    </div>\n\n    \n    <slot :controls=\"controls\" />\n  </div>\n</template>\n\n<style scoped>\n.controls-toolbar {\n  --item-size: 60px;\n  --gap-size: 8px;\n}\n\n\n.controls-toolbar::-webkit-scrollbar {\n  width: 8px;\n  height: 8px;\n}\n\n.controls-toolbar::-webkit-scrollbar-track {\n  background: hsl(var(--muted));\n  border-radius: 4px;\n}\n\n.controls-toolbar::-webkit-scrollbar-thumb {\n  background: hsl(var(--muted-foreground) / 0.3);\n  border-radius: 4px;\n}\n\n.controls-toolbar::-webkit-scrollbar-thumb:hover {\n  background: hsl(var(--muted-foreground) / 0.5);\n}\n\n\n.control-item:hover .control-preview {\n  transform: translateY(-2px);\n}\n\n.control-item:active .control-preview {\n  transform: translateY(0);\n}\n</style>\n"
      },
      {
        "name": "index.ts",
        "path": "registry/new-york/components/control-grid/index.ts",
        "source": "\n\nimport type { Component, InjectionKey, Ref } from 'vue';\n\nexport { default as ControlGrid } from './ControlGrid.vue';\nexport { default as ControlGridToolbar } from './ControlGridToolbar.vue';\nexport { default as ControlGridItem } from './ControlGridItem.vue';\n\n\nexport { useControlsGrid } from '../../composables/use-controls-grid/useControlsGrid';\nexport { useControlRegistry } from '../../composables/use-control-registry/useControlRegistry';\n\n\n\n\n\n\nexport interface ComponentToRegister {\n  \n  name: string;\n  \n  component: Component;\n}\n\n\nexport interface GridItem {\n  \n  id: string;\n  \n  x: number;\n  \n  y: number;\n  \n  width: number;\n  \n  height: number;\n  \n  component?: any;\n  \n  color?: string;\n  \n  [key: string]: any;\n}\n\n\nexport interface GridPosition {\n  \n  x: number;\n  \n  y: number;\n}\n\n\nexport interface GridDimensions {\n  \n  width: number;\n  \n  height: number;\n}\n\n\nexport interface GridConfig {\n  \n  cellSize: number;\n  \n  gap: number;\n  \n  columns: number;\n  \n  rows: number;\n  \n  width: number;\n  \n  height: number;\n}\n\n\nexport interface GridItemTemplate extends Omit<GridItem, 'x' | 'y'> {\n  \n  label?: string;\n  \n  color?: string;\n  \n  icon?: string;\n}\n\n\nexport interface GridEvents {\n  \n  'update:items': (items: GridItem[]) => void;\n  \n  'item-placed': (item: GridItem) => void;\n  \n  'item-moved': (item: GridItem) => void;\n  \n  'item-removed': (id: string) => void;\n  \n  'config-changed': (config: GridConfig) => void;\n}\n\n\nexport interface GridMethods {\n  \n  addItem: (item: Omit<GridItem, 'x' | 'y'>) => GridItem | null;\n  \n  addItemByComponent: (\n    componentName: string,\n    width?: number,\n    height?: number,\n    additionalProps?: Record<string, any>\n  ) => GridItem | null;\n  \n  removeItem: (id: string) => void;\n  \n  clearGrid: () => void;\n  \n  getComponent: (name: string) => Component | undefined;\n  \n  getRegisteredComponents: () => string[];\n  \n  isCellOccupied?: (x: number, y: number, excludeId?: string) => boolean;\n  \n  isValidPlacement?: (\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    excludeId?: string\n  ) => boolean;\n  \n  findAvailablePosition?: (width: number, height: number) => GridPosition | null;\n}\n\n\nexport interface GridProps {\n  \n  cellSize?: number;\n  \n  gap?: number;\n  \n  minColumns?: number;\n  \n  items?: GridItem[];\n  \n  showGrid?: boolean;\n  \n  snapToGrid?: boolean;\n  \n  components?: ComponentToRegister[];\n}\n\n\nexport interface DragState {\n  \n  item: GridItem | null;\n  \n  fromGrid: boolean;\n  \n  hoverPosition: GridPosition | null;\n  \n  isValid: boolean;\n}\n\n\n\n\n\n\nexport class GridUtils {\n  \n  static pixelToGrid(pixelX: number, pixelY: number, cellSize: number, gap: number): GridPosition {\n    const x = Math.floor(pixelX / (cellSize + gap));\n    const y = Math.floor(pixelY / (cellSize + gap));\n    return { x, y };\n  }\n\n  \n  static gridToPixel(\n    gridX: number,\n    gridY: number,\n    cellSize: number,\n    gap: number\n  ): { x: number; y: number } {\n    const x = gridX * (cellSize + gap);\n    const y = gridY * (cellSize + gap);\n    return { x, y };\n  }\n\n  \n  static doItemsOverlap(item1: GridItem, item2: GridItem): boolean {\n    return !(\n      item1.x + item1.width <= item2.x ||\n      item2.x + item2.width <= item1.x ||\n      item1.y + item1.height <= item2.y ||\n      item2.y + item2.height <= item1.y\n    );\n  }\n\n  \n  static calculateArea(item: GridItem): number {\n    return item.width * item.height;\n  }\n\n  \n  static generateId(prefix = 'item'): string {\n    return `${prefix}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  \n  static cloneItemAtPosition(item: GridItem, x: number, y: number): GridItem {\n    return {\n      ...item,\n      id: this.generateId(item.id.split('-')[0]),\n      x,\n      y,\n    };\n  }\n\n  \n  static isValidItem(item: Partial<GridItem>): boolean {\n    return (\n      typeof item.id === 'string' &&\n      typeof item.width === 'number' &&\n      typeof item.height === 'number' &&\n      item.width > 0 &&\n      item.height > 0\n    );\n  }\n\n  \n  static sortItems(items: GridItem[]): GridItem[] {\n    return [...items].sort((a, b) => {\n      if (a.y !== b.y) return a.y - b.y;\n      return a.x - b.x;\n    });\n  }\n\n  \n  static findOverlappingItems(\n    items: GridItem[],\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    excludeId?: string\n  ): GridItem[] {\n    const testItem: GridItem = {\n      id: 'test',\n      x,\n      y,\n      width,\n      height,\n    };\n\n    return items.filter((item) => {\n      if (excludeId && item.id === excludeId) return false;\n      return this.doItemsOverlap(item, testItem);\n    });\n  }\n}\n\n\n\n\n\n\n\n\nexport const ControlGridItemsKey: InjectionKey<Ref<GridItem[]>> = Symbol('ControlGridItems');\n\n\nexport const ControlGridConfigKey: InjectionKey<Ref<GridConfig>> = Symbol('ControlGridConfig');\n\n\nexport const ControlGridHoverKey: InjectionKey<Ref<GridPosition | null>> =\n  Symbol('ControlGridHover');\n\n\nexport const ControlGridDragStateKey: InjectionKey<Ref<DragState>> = Symbol('ControlGridDragState');\n\n\nexport const ControlGridComponentRegistryKey: InjectionKey<Ref<Map<string, Component>>> = Symbol(\n  'ControlGridComponentRegistry'\n);\n\n\nexport const ControlGridAddItemKey: InjectionKey<GridMethods['addItem']> =\n  Symbol('ControlGridAddItem');\n\nexport const ControlGridAddItemByComponentKey: InjectionKey<GridMethods['addItemByComponent']> =\n  Symbol('ControlGridAddItemByComponent');\n\nexport const ControlGridRemoveItemKey: InjectionKey<GridMethods['removeItem']> =\n  Symbol('ControlGridRemoveItem');\n\nexport const ControlGridClearGridKey: InjectionKey<GridMethods['clearGrid']> =\n  Symbol('ControlGridClearGrid');\n\nexport const ControlGridGetComponentKey: InjectionKey<GridMethods['getComponent']> =\n  Symbol('ControlGridGetComponent');\n\nexport const ControlGridGetRegisteredComponentsKey: InjectionKey<\n  GridMethods['getRegisteredComponents']\n> = Symbol('ControlGridGetRegisteredComponents');\n"
      }
    ]
  },
  "drag-drop-provider": {
    "dependsOn": [
      {
        "path": "composables/use-drag-drop",
        "files": [
          "useDragDrop.ts"
        ]
      },
      {
        "path": "composables/use-drag-drop-context",
        "files": [
          "useDragDropContext.ts"
        ]
      }
    ],
    "usedBy": [],
    "files": [
      {
        "name": "DragDropProvider.vue",
        "path": "registry/new-york/components/drag-drop-provider/DragDropProvider.vue",
        "source": "<script setup lang=\"ts\">\nimport { provide, readonly } from 'vue';\nimport {\n  useDragDrop,\n  type UseDragDropOptions,\n  type UseDragDropReturn,\n} from '../../composables/use-drag-drop/useDragDrop';\nimport { DRAG_DROP_INJECTION_KEY } from '../../composables/use-drag-drop-context/useDragDropContext';\n\ninterface Props extends UseDragDropOptions {\n  \n  mode?: 'drag' | 'resize' | 'both';\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  gap: 0,\n  allowCollision: false,\n  mode: 'drag',\n});\n\n\nconst dragDropInstance = useDragDrop({\n  containerRef: props.containerRef,\n  unitSize: props.unitSize,\n  gap: props.gap,\n  allowCollision: props.allowCollision,\n  validatePlacement: props.validatePlacement,\n});\n\n\nprovide(DRAG_DROP_INJECTION_KEY, {\n  ...dragDropInstance,\n  options: readonly({\n    containerRef: props.containerRef,\n    unitSize: props.unitSize,\n    gap: props.gap,\n    allowCollision: props.allowCollision,\n    mode: props.mode,\n  }),\n});\n\n\ndefineExpose(dragDropInstance);\n</script>\n\n<template>\n  <slot\n    v-bind=\"{\n      dragState: dragDropInstance.dragState.value,\n      dragOffset: dragDropInstance.dragOffset.value,\n      containerBounds: dragDropInstance.containerBounds,\n      startDrag: dragDropInstance.startDrag,\n      handleDragOver: dragDropInstance.handleDragOver,\n      handleDragOverSimple: dragDropInstance.handleDragOverSimple,\n      endDrag: dragDropInstance.endDrag,\n      getVirtualBounds: dragDropInstance.getVirtualBounds,\n      getItemFromDataTransfer: dragDropInstance.getItemFromDataTransfer,\n    }\"\n  />\n</template>\n"
      },
      {
        "name": "index.ts",
        "path": "registry/new-york/components/drag-drop-provider/index.ts",
        "source": "\n\nexport { default as DragDropProvider } from './DragDropProvider.vue';\n"
      }
    ]
  },
  "media-devices-provider": {
    "dependsOn": [
      {
        "path": "composables/use-media-devices",
        "files": [
          "foo.ts",
          "useMediaDevices.ts"
        ]
      }
    ],
    "usedBy": [],
    "files": [
      {
        "name": "AudioDevice.vue",
        "path": "registry/new-york/components/media-devices-provider/AudioDevice.vue",
        "source": "<script setup lang=\"ts\">\n\n\nimport { ref, watch, onMounted, onBeforeUnmount, computed, inject, type Ref } from 'vue';\nimport {\n  MediaDevicesStartKey,\n  MediaDevicesStopKey,\n  MediaDevicesLoadingKey,\n  MediaDevicesPermissionsKey,\n  MediaDevicesActiveStreamsKey,\n  type MediaPermissions,\n} from '.';\nimport type { MediaDevicesStartFn, MediaDevicesStopFn } from '.';\n\nexport interface AudioDeviceProps {\n  \n  autoStart?: boolean;\n  \n  deviceId: string;\n\n  \n\n  \n  echoCancellation?: boolean;\n  \n  noiseSuppression?: boolean;\n  \n  autoGainControl?: boolean;\n  \n  sampleRate?: number | { min?: number; max?: number; ideal?: number };\n  \n  sampleSize?: number | { min?: number; max?: number; ideal?: number };\n\n  \n  constraints?: MediaStreamConstraints;\n}\n\nconst props = withDefaults(defineProps<AudioDeviceProps>(), {\n  autoStart: false,\n});\n\nconst emit = defineEmits<{\n  stream: [stream: MediaStream | null];\n  error: [error: Error];\n  started: [];\n  stopped: [];\n}>();\n\n\nconst providerStart = inject<MediaDevicesStartFn>(MediaDevicesStartKey);\nconst providerStop = inject<MediaDevicesStopFn>(MediaDevicesStopKey);\nconst providerIsLoading = inject<Ref<boolean>>(MediaDevicesLoadingKey, ref(false));\nconst providerPermissions = inject<Ref<MediaPermissions>>(\n  MediaDevicesPermissionsKey,\n  ref({ camera: 'unknown', microphone: 'unknown' })\n);\nconst providerActiveStreams = inject<Readonly<Ref<ReadonlyMap<string, MediaStream>>>>(\n  MediaDevicesActiveStreamsKey,\n  computed(() => new Map() as ReadonlyMap<string, MediaStream>)\n);\n\nconst stream = ref<MediaStream | null>(null);\nconst error = ref<Error | null>(null);\nconst isActive = ref(false);\nconst isLoading = ref(false);\nconst currentDeviceId = ref<string | undefined>(undefined);\n\n\nconst buildConstraints = (): MediaStreamConstraints => {\n  \n  if (props.constraints) {\n    return props.constraints;\n  }\n\n  const audioConstraints: MediaTrackConstraints = {\n    deviceId: { exact: props.deviceId },\n    echoCancellation: props.echoCancellation,\n    noiseSuppression: props.noiseSuppression,\n    autoGainControl: props.autoGainControl,\n    sampleRate: props.sampleRate\n      ? typeof props.sampleRate === 'number'\n        ? { ideal: props.sampleRate }\n        : props.sampleRate\n      : undefined,\n    sampleSize: props.sampleSize\n      ? typeof props.sampleSize === 'number'\n        ? { ideal: props.sampleSize }\n        : props.sampleSize\n      : undefined,\n  };\n\n  return {\n    video: false,\n    audio: audioConstraints,\n  };\n};\n\n\nconst start = async () => {\n  if (typeof navigator === 'undefined' || !navigator.mediaDevices) {\n    return;\n  }\n\n  if (isActive.value || isLoading.value) {\n    return;\n  }\n\n  try {\n    isLoading.value = true;\n    error.value = null;\n    const constraints = buildConstraints();\n\n    if (providerStart) {\n      stream.value = await providerStart(props.deviceId, constraints);\n    } else {\n      stream.value = await navigator.mediaDevices.getUserMedia(constraints);\n    }\n\n    currentDeviceId.value = props.deviceId;\n    isActive.value = true;\n    emit('stream', stream.value);\n    emit('started');\n  } catch (err) {\n    const errorObj = err as Error;\n    error.value = errorObj;\n    emit('error', errorObj);\n  } finally {\n    isLoading.value = false;\n  }\n};\n\n\nconst stop = () => {\n  if (!isActive.value) return;\n\n  const deviceIdToStop = currentDeviceId.value;\n\n  if (deviceIdToStop && providerStop) {\n    providerStop(deviceIdToStop);\n  } else if (stream.value) {\n    stream.value.getTracks().forEach((track) => track.stop());\n  }\n\n  stream.value = null;\n  isActive.value = false;\n  currentDeviceId.value = undefined;\n  emit('stream', null);\n  emit('stopped');\n};\n\n\nconst switchDevice = async () => {\n  const previousDeviceId = currentDeviceId.value;\n\n  \n  stream.value = null;\n  isActive.value = false;\n  currentDeviceId.value = undefined;\n\n  \n  emit('stream', null);\n\n  \n  await start();\n};\n\n\nwatch(\n  () => [\n    props.deviceId,\n    props.echoCancellation,\n    props.noiseSuppression,\n    props.autoGainControl,\n    props.sampleRate,\n    props.sampleSize,\n    props.constraints,\n  ],\n  async (newVals, oldVals) => {\n    const deviceIdChanged = newVals[0] !== oldVals?.[0];\n\n    if (deviceIdChanged) {\n      \n      if (isActive.value) {\n        \n        await switchDevice();\n      } else if (props.autoStart) {\n        \n        await start();\n      }\n    } else if (isActive.value) {\n      \n      stop();\n      await new Promise((resolve) => setTimeout(resolve, 50));\n      await start();\n    }\n  }\n);\n\nonMounted(() => {\n  if (props.autoStart) {\n    start();\n  }\n});\n\nonBeforeUnmount(() => {\n  stop();\n});\n\ndefineExpose({\n  start,\n  stop,\n  stream: computed(() => stream.value),\n  isActive: computed(() => isActive.value),\n  isLoading: computed(() => isLoading.value),\n  providerIsLoading: computed(() => providerIsLoading.value),\n  providerPermissions: computed(() => providerPermissions.value),\n  providerActiveStreams: computed(() => providerActiveStreams.value),\n  error: computed(() => error.value),\n});\n</script>\n\n<template>\n  <slot\n    :stream=\"stream\"\n    :is-active=\"isActive\"\n    :is-loading=\"isLoading\"\n    :provider-is-loading=\"providerIsLoading\"\n    :provider-permissions=\"providerPermissions\"\n    :provider-active-streams=\"providerActiveStreams\"\n    :error=\"error\"\n    :start=\"start\"\n    :stop=\"stop\"\n  />\n</template>\n\n<style scoped></style>\n"
      },
      {
        "name": "MediaDevicesProvider.vue",
        "path": "registry/new-york/components/media-devices-provider/MediaDevicesProvider.vue",
        "source": "<script setup lang=\"ts\">\n\n\nimport { provide, onMounted, toRef, type Ref } from 'vue';\nimport { useMediaDevices } from '~~/registry/new-york/composables/use-media-devices/useMediaDevices';\nimport {\n  MediaDevicesKey,\n  MediaDevicesErrorsKey,\n  MediaDevicesLoadingKey,\n  MediaDevicesPermissionsKey,\n  MediaDevicesActiveStreamsKey,\n  MediaDevicesStartKey,\n  MediaDevicesStopKey,\n  MediaDevicesStopAllKey,\n  type MediaDevicesStartFn,\n  type MediaDevicesStopFn,\n  type MediaDevicesStopAllFn,\n  type MediaDeviceType,\n  type MediaPermissions,\n} from '.';\n\nexport interface MediaDevicesProviderProps {\n  \n  type?: MediaDeviceType;\n  \n  open?: boolean;\n}\n\nconst props = withDefaults(defineProps<MediaDevicesProviderProps>(), {\n  type: 'all',\n  open: false,\n});\n\nconst emit = defineEmits<{\n  \n  streamStarted: [deviceId: string, stream: MediaStream];\n  \n  streamStopped: [deviceId: string];\n  \n  allStreamsStopped: [];\n  \n  devicesUpdated: [devices: MediaDeviceInfo[]];\n  \n  error: [error: Error];\n}>();\n\n\nconst {\n  devices,\n  cameras,\n  microphones,\n  speakers,\n  errors,\n  isLoading,\n  permissions,\n  activeStreams,\n  startStream,\n  stopStream,\n  stopAllStreams,\n  updateAvailableDevices,\n  ensurePermissions,\n  initialize,\n} = useMediaDevices({\n  type: toRef(props, 'type'),\n  open: toRef(props, 'open'),\n  onStreamStarted: (deviceId, stream) => emit('streamStarted', deviceId, stream),\n  onStreamStopped: (deviceId) => emit('streamStopped', deviceId),\n  onAllStreamsStopped: () => emit('allStreamsStopped'),\n  onDevicesUpdated: (devices) => emit('devicesUpdated', devices),\n  onError: (error) => emit('error', error),\n});\n\n\n\n\nprovide<Ref<MediaDeviceInfo[]>>(MediaDevicesKey, devices);\n\n\nprovide<Ref<Error[]>>(MediaDevicesErrorsKey, errors);\n\n\nprovide<Ref<boolean>>(MediaDevicesLoadingKey, isLoading);\n\n\nprovide<Ref<MediaPermissions>>(MediaDevicesPermissionsKey, permissions);\n\n\nprovide(MediaDevicesActiveStreamsKey, activeStreams);\n\n\nprovide<MediaDevicesStartFn>(MediaDevicesStartKey, startStream);\n\n\nprovide<MediaDevicesStopFn>(MediaDevicesStopKey, stopStream);\n\n\nprovide<MediaDevicesStopAllFn>(MediaDevicesStopAllKey, stopAllStreams);\n\n\nonMounted(async () => {\n  await initialize();\n});\n</script>\n\n<template>\n  \n  <slot\n    :devices=\"devices\"\n    :errors=\"errors\"\n    :is-loading=\"isLoading\"\n    :permissions=\"permissions\"\n    :active-streams=\"activeStreams\"\n    :cameras=\"cameras\"\n    :microphones=\"microphones\"\n    :speakers=\"speakers\"\n    :start=\"startStream\"\n    :stop=\"stopStream\"\n    :stop-all=\"stopAllStreams\"\n    :cached-streams-count=\"activeStreams.size\"\n  />\n</template>\n\n<style scoped></style>\n"
      },
      {
        "name": "VideoDevice.vue",
        "path": "registry/new-york/components/media-devices-provider/VideoDevice.vue",
        "source": "<script setup lang=\"ts\">\n\n\nimport { ref, watch, onMounted, onBeforeUnmount, computed, inject, type Ref } from 'vue';\nimport {\n  MediaDevicesStartKey,\n  MediaDevicesStopKey,\n  MediaDevicesLoadingKey,\n  MediaDevicesPermissionsKey,\n  MediaDevicesActiveStreamsKey,\n  type MediaPermissions,\n} from '.';\nimport type { MediaDevicesStartFn, MediaDevicesStopFn } from '.';\n\nexport interface VideoDeviceProps {\n  \n  autoStart?: boolean;\n  \n  deviceId?: string;\n\n  \n\n  \n  width?: number | { min?: number; max?: number; ideal?: number };\n  \n  height?: number | { min?: number; max?: number; ideal?: number };\n  \n  frameRate?: number | { min?: number; max?: number; ideal?: number };\n  \n  facingMode?: 'user' | 'environment' | 'left' | 'right';\n  \n  aspectRatio?: number | { min?: number; max?: number; ideal?: number };\n\n  \n  constraints?: MediaStreamConstraints;\n}\n\nconst props = withDefaults(defineProps<VideoDeviceProps>(), {\n  autoStart: false,\n});\n\nconst emit = defineEmits<{\n  stream: [stream: MediaStream | null];\n  error: [error: Error];\n  started: [];\n  stopped: [];\n}>();\n\n\nconst providerStart = inject<MediaDevicesStartFn>(MediaDevicesStartKey);\nconst providerStop = inject<MediaDevicesStopFn>(MediaDevicesStopKey);\nconst providerIsLoading = inject<Ref<boolean>>(MediaDevicesLoadingKey, ref(false));\nconst providerPermissions = inject<Ref<MediaPermissions>>(\n  MediaDevicesPermissionsKey,\n  ref({ camera: 'unknown', microphone: 'unknown' })\n);\nconst providerActiveStreams = inject<Readonly<Ref<ReadonlyMap<string, MediaStream>>>>(\n  MediaDevicesActiveStreamsKey,\n  computed(() => new Map() as ReadonlyMap<string, MediaStream>)\n);\n\nconst stream = ref<MediaStream | null>(null);\nconst error = ref<Error | null>(null);\nconst isActive = ref(false);\nconst isLoading = ref(false);\nconst currentDeviceId = ref<string | undefined>(undefined);\n\n\nconst buildConstraints = (): MediaStreamConstraints => {\n  \n  if (props.constraints) {\n    return props.constraints;\n  }\n\n  \n  if (!props.deviceId && !props.facingMode) {\n    throw new Error('Either deviceId or facingMode must be provided');\n  }\n\n  const videoConstraints: MediaTrackConstraints = {\n    \n    \n    \n    ...(props.facingMode\n      ? { facingMode: { ideal: props.facingMode } }\n      : { deviceId: { exact: props.deviceId } }),\n    width: props.width\n      ? typeof props.width === 'number'\n        ? { ideal: props.width }\n        : props.width\n      : undefined,\n    height: props.height\n      ? typeof props.height === 'number'\n        ? { ideal: props.height }\n        : props.height\n      : undefined,\n    aspectRatio: props.aspectRatio\n      ? typeof props.aspectRatio === 'number'\n        ? { ideal: props.aspectRatio }\n        : props.aspectRatio\n      : undefined,\n    frameRate: props.frameRate\n      ? typeof props.frameRate === 'number'\n        ? { ideal: props.frameRate }\n        : props.frameRate\n      : undefined,\n  };\n\n  return {\n    video: videoConstraints,\n    audio: false,\n  };\n};\n\n\nconst start = async () => {\n  if (typeof navigator === 'undefined' || !navigator.mediaDevices) {\n    return;\n  }\n\n  if (isActive.value || isLoading.value) {\n    return;\n  }\n\n  try {\n    isLoading.value = true;\n    error.value = null;\n    const constraints = buildConstraints();\n\n    if (providerStart && props.deviceId && !props.facingMode) {\n      \n      \n      stream.value = await providerStart(props.deviceId, constraints);\n    } else {\n      stream.value = await navigator.mediaDevices.getUserMedia(constraints);\n    }\n\n    currentDeviceId.value = props.deviceId;\n    isActive.value = true;\n    emit('stream', stream.value);\n    emit('started');\n  } catch (err) {\n    const errorObj = err as Error;\n    error.value = errorObj;\n    emit('error', errorObj);\n  } finally {\n    isLoading.value = false;\n  }\n};\n\n\nconst stop = () => {\n  if (!isActive.value) return;\n\n  const deviceIdToStop = currentDeviceId.value;\n\n  if (deviceIdToStop && providerStop) {\n    providerStop(deviceIdToStop);\n  } else if (stream.value) {\n    stream.value.getTracks().forEach((track) => track.stop());\n  }\n\n  stream.value = null;\n  isActive.value = false;\n  currentDeviceId.value = undefined;\n  emit('stream', null);\n  emit('stopped');\n};\n\n\nconst switchDevice = async () => {\n  const previousDeviceId = currentDeviceId.value;\n\n  \n  stream.value = null;\n  isActive.value = false;\n  currentDeviceId.value = undefined;\n\n  \n  emit('stream', null);\n\n  \n  await start();\n};\n\n\nwatch(\n  () => [\n    props.deviceId,\n    props.width,\n    props.height,\n    props.frameRate,\n    props.facingMode,\n    props.aspectRatio,\n    props.constraints,\n  ],\n  async (newVals, oldVals) => {\n    const deviceIdChanged = newVals[0] !== oldVals?.[0];\n\n    if (deviceIdChanged) {\n      \n      if (isActive.value) {\n        \n        await switchDevice();\n      } else if (props.autoStart) {\n        \n        await start();\n      }\n    } else if (isActive.value) {\n      \n      stop();\n      await new Promise((resolve) => setTimeout(resolve, 50));\n      await start();\n    }\n  }\n);\n\nonMounted(() => {\n  if (props.autoStart) {\n    start();\n  }\n});\n\nonBeforeUnmount(() => {\n  stop();\n});\n\ndefineExpose({\n  start,\n  stop,\n  stream: computed(() => stream.value),\n  isActive: computed(() => isActive.value),\n  isLoading: computed(() => isLoading.value),\n  providerIsLoading: computed(() => providerIsLoading.value),\n  providerPermissions: computed(() => providerPermissions.value),\n  providerActiveStreams: computed(() => providerActiveStreams.value),\n  error: computed(() => error.value),\n});\n</script>\n\n<template>\n  <slot\n    :stream=\"stream\"\n    :is-active=\"isActive\"\n    :is-loading=\"isLoading\"\n    :provider-is-loading=\"providerIsLoading\"\n    :provider-permissions=\"providerPermissions\"\n    :provider-active-streams=\"providerActiveStreams\"\n    :error=\"error\"\n    :start=\"start\"\n    :stop=\"stop\"\n  />\n</template>\n\n<style scoped></style>\n"
      },
      {
        "name": "index.ts",
        "path": "registry/new-york/components/media-devices-provider/index.ts",
        "source": "\nimport type { InjectionKey, Ref } from 'vue';\n\nexport { default as MediaDevicesProvider } from './MediaDevicesProvider.vue';\nexport { default as VideoDevice } from './VideoDevice.vue';\nexport { default as AudioDevice } from './AudioDevice.vue';\n\nexport { type MediaDevicesProviderProps } from './MediaDevicesProvider.vue';\nexport { type VideoDeviceProps } from './VideoDevice.vue';\nexport { type AudioDeviceProps } from './AudioDevice.vue';\n\n\nexport type MediaDeviceType = 'camera' | 'microphone' | 'all';\n\n\nexport type MediaDeviceKind = 'videoinput' | 'audioinput' | 'audiooutput';\n\n\nexport type MediaPermissionState = 'granted' | 'denied' | 'prompt' | 'unknown';\n\n\nexport interface MediaPermissions {\n  camera: MediaPermissionState;\n  microphone: MediaPermissionState;\n}\n\n\nexport interface FilteredDevices {\n  cameras: MediaDeviceInfo[];\n  microphones: MediaDeviceInfo[];\n  speakers: MediaDeviceInfo[];\n}\n\n\nexport type CameraConstraints = MediaStreamConstraints & {\n  video: MediaTrackConstraints | boolean;\n  audio?: MediaTrackConstraints | boolean;\n};\n\n\nexport type MicrophoneConstraints = MediaStreamConstraints & {\n  audio: MediaTrackConstraints | boolean;\n  video?: MediaTrackConstraints | boolean;\n};\n\n\nexport type DeviceConstraints = CameraConstraints | MicrophoneConstraints | MediaStreamConstraints;\n\n\nexport type MediaDeviceErrorName =\n  | 'NotFoundError'\n  | 'NotAllowedError'\n  | 'NotReadableError'\n  | 'OverconstrainedError'\n  | 'TypeError'\n  | 'AbortError'\n  | 'SecurityError';\n\n\nexport interface MediaDeviceError extends Error {\n  name: MediaDeviceErrorName;\n  constraint?: string;\n}\n\n\nexport interface MediaDevicesProviderSlotProps {\n  \n  devices: MediaDeviceInfo[];\n  \n  cameras: MediaDeviceInfo[];\n  \n  microphones: MediaDeviceInfo[];\n  \n  speakers: MediaDeviceInfo[];\n  \n  errors: Error[];\n  \n  isLoading: boolean;\n  \n  permissions: MediaPermissions;\n  \n  activeStreams: ReadonlyMap<string, MediaStream>;\n  \n  start: MediaDevicesStartFn;\n  \n  stop: MediaDevicesStopFn;\n  \n  stopAll: MediaDevicesStopAllFn;\n  \n  cachedStreamsCount: number;\n}\n\n\nexport type MediaDevicesStartFn = (\n  deviceId: string,\n  constraints: MediaStreamConstraints\n) => Promise<MediaStream>;\n\n\nexport type MediaDevicesStopFn = (deviceId: string) => void;\n\n\nexport type MediaDevicesStopAllFn = () => void;\n\n\nexport type MediaDevicesIsActiveStreamFn = (deviceId: string) => boolean;\n\nexport const MediaDevicesKey: InjectionKey<Ref<MediaDeviceInfo[]>> = Symbol('MediaDevices');\nexport const MediaDevicesErrorsKey: InjectionKey<Ref<Error[]>> = Symbol('MediaDevicesErrors');\nexport const MediaDevicesLoadingKey: InjectionKey<Ref<boolean>> = Symbol('MediaDevicesLoading');\nexport const MediaDevicesPermissionsKey: InjectionKey<Ref<MediaPermissions>> =\n  Symbol('MediaDevicesPermissions');\nexport const MediaDevicesActiveStreamsKey: InjectionKey<\n  Readonly<Ref<ReadonlyMap<string, MediaStream>>>\n> = Symbol('MediaDevicesActiveStreams');\nexport const MediaDevicesStartKey: InjectionKey<MediaDevicesStartFn> = Symbol('MediaDevicesStart');\nexport const MediaDevicesStopKey: InjectionKey<MediaDevicesStopFn> = Symbol('MediaDevicesStop');\nexport const MediaDevicesStopAllKey: InjectionKey<MediaDevicesStopAllFn> =\n  Symbol('MediaDevicesStopAll');\n\n\nexport { VideoPresets, AudioPresets, MediaPresets } from './presets';\n"
      },
      {
        "name": "presets.ts",
        "path": "registry/new-york/components/media-devices-provider/presets.ts",
        "source": "\n\nexport const VideoPresets = {\n  \n  sd: {\n    width: 640,\n    height: 480,\n    frameRate: 30,\n  },\n\n  \n  hd: {\n    width: 1280,\n    height: 720,\n    frameRate: 30,\n  },\n\n  \n  fullHd: {\n    width: 1920,\n    height: 1080,\n    frameRate: 30,\n  },\n\n  \n  uhd4k: {\n    width: 3840,\n    height: 2160,\n    frameRate: 30,\n  },\n\n  \n  adaptiveHd: {\n    width: { min: 640, ideal: 1920, max: 3840 },\n    height: { min: 480, ideal: 1080, max: 2160 },\n    frameRate: { min: 24, ideal: 30, max: 60 },\n  },\n\n  \n  mobileFront: {\n    width: { ideal: 1280 },\n    height: { ideal: 720 },\n    frameRate: { ideal: 30 },\n    facingMode: 'user' as const,\n  },\n\n  \n  mobileBack: {\n    width: { ideal: 1920 },\n    height: { ideal: 1080 },\n    frameRate: { ideal: 30 },\n    facingMode: 'environment' as const,\n  },\n\n  \n  conference: {\n    width: 1280,\n    height: 720,\n    frameRate: 30,\n    aspectRatio: 1.777, \n  },\n\n  \n  screenRecording: {\n    width: { ideal: 1920 },\n    height: { ideal: 1080 },\n    frameRate: { ideal: 60 },\n    aspectRatio: 1.777,\n  },\n} as const;\n\n\nexport const AudioPresets = {\n  \n  default: {\n    echoCancellation: true,\n    noiseSuppression: true,\n    autoGainControl: true,\n  },\n\n  \n  highQuality: {\n    echoCancellation: false,\n    noiseSuppression: false,\n    autoGainControl: false,\n    sampleRate: 48000,\n  },\n\n  \n  voice: {\n    echoCancellation: true,\n    noiseSuppression: true,\n    autoGainControl: true,\n    sampleRate: 48000,\n  },\n\n  \n  conference: {\n    echoCancellation: true,\n    noiseSuppression: true,\n    autoGainControl: true,\n    sampleRate: { ideal: 48000 },\n  },\n\n  \n  raw: {\n    echoCancellation: false,\n    noiseSuppression: false,\n    autoGainControl: false,\n  },\n} as const;\n\n\nexport const MediaPresets = {\n  \n  videoConference: {\n    ...VideoPresets.conference,\n    ...AudioPresets.conference,\n  },\n\n  \n  screenRecording: {\n    ...VideoPresets.screenRecording,\n    ...AudioPresets.voice,\n  },\n\n  \n  podcast: {\n    ...AudioPresets.highQuality,\n  },\n\n  \n  mobileSelfie: {\n    ...VideoPresets.mobileFront,\n    ...AudioPresets.default,\n  },\n\n  \n  mobileVideo: {\n    ...VideoPresets.mobileBack,\n    ...AudioPresets.default,\n  },\n} as const;\n"
      }
    ]
  },
  "screen-share-provider": {
    "dependsOn": [
      {
        "path": "composables/use-screen-share",
        "files": [
          "useScreenShare.ts"
        ]
      }
    ],
    "usedBy": [],
    "files": [
      {
        "name": "ScreenShareProvider.vue",
        "path": "registry/new-york/components/screen-share-provider/ScreenShareProvider.vue",
        "source": "<script setup lang=\"ts\">\n\n\nimport { provide, watch, nextTick, type Ref } from 'vue';\nimport { useScreenShare } from '~~/registry/new-york/composables/use-screen-share/useScreenShare';\nimport {\n  ScreenShareStreamKey,\n  ScreenShareStateKey,\n  ScreenShareTypeKey,\n  ScreenShareErrorsKey,\n  ScreenShareStartKey,\n  ScreenShareStopKey,\n  type ScreenShareOptions,\n  type ScreenShareState,\n  type ScreenShareType,\n  type ScreenShareStartFn,\n  type ScreenShareStopFn,\n} from '.';\n\nexport interface ScreenShareProviderProps {\n  \n  autoStart?: boolean;\n  \n  defaultOptions?: ScreenShareOptions;\n}\n\nconst props = withDefaults(defineProps<ScreenShareProviderProps>(), {\n  autoStart: false,\n});\n\nconst emit = defineEmits<{\n  shareStarted: [stream: MediaStream];\n  shareStopped: [];\n  error: [error: Error];\n}>();\n\n\nconst {\n  screenStream,\n  shareState,\n  shareType,\n  errors,\n  isSharing,\n  startScreenShare,\n  stopScreenShare,\n} = useScreenShare({\n  defaultOptions: props.defaultOptions,\n  onShareStarted: (stream) => emit('shareStarted', stream),\n  onShareStopped: () => emit('shareStopped'),\n  onError: (error) => emit('error', error),\n});\n\n\nprovide<Ref<MediaStream | null>>(ScreenShareStreamKey, screenStream);\nprovide<Ref<ScreenShareState>>(ScreenShareStateKey, shareState);\nprovide<Ref<ScreenShareType | null>>(ScreenShareTypeKey, shareType);\nprovide<Ref<Error[]>>(ScreenShareErrorsKey, errors);\nprovide<ScreenShareStartFn>(ScreenShareStartKey, startScreenShare);\nprovide<ScreenShareStopFn>(ScreenShareStopKey, stopScreenShare);\n\n\nwatch(\n  () => props.autoStart,\n  async (autoStart) => {\n    if (autoStart) {\n      await nextTick();\n      try {\n        await startScreenShare(props.defaultOptions);\n      } catch (error) {\n        \n      }\n    }\n  },\n  { immediate: true }\n);\n</script>\n\n<template>\n  \n  <slot\n    :screen-stream=\"screenStream\"\n    :share-state=\"shareState\"\n    :share-type=\"shareType\"\n    :errors=\"errors\"\n    :is-sharing=\"isSharing\"\n    :start-share=\"startScreenShare\"\n    :stop-share=\"stopScreenShare\"\n  />\n</template>\n\n<style scoped></style>\n"
      },
      {
        "name": "ScreenShareViewer.vue",
        "path": "registry/new-york/components/screen-share-provider/ScreenShareViewer.vue",
        "source": "<script setup lang=\"ts\">\n\n\nimport { inject, ref, watch, onBeforeUnmount, computed } from 'vue';\nimport {\n  ScreenShareStreamKey,\n  ScreenShareStateKey,\n  ScreenShareStartKey,\n  ScreenShareStopKey,\n  type ScreenShareOptions,\n} from '.';\n\nexport interface ScreenShareViewerProps {\n  \n  options?: ScreenShareOptions;\n  \n  autoPlay?: boolean;\n  \n  muted?: boolean;\n  \n  controls?: boolean;\n  \n  class?: string;\n  \n  autoStart?: boolean;\n}\n\nconst props = withDefaults(defineProps<ScreenShareViewerProps>(), {\n  autoPlay: true,\n  muted: true,\n  controls: false,\n  autoStart: false,\n});\n\nconst emit = defineEmits<{\n  playing: [];\n  paused: [];\n  error: [error: Event];\n}>();\n\n\nconst screenStream = inject(ScreenShareStreamKey);\nconst shareState = inject(ScreenShareStateKey);\nconst startShare = inject(ScreenShareStartKey);\nconst stopShare = inject(ScreenShareStopKey);\n\n\nconst videoRef = ref<HTMLVideoElement | null>(null);\n\n\nconst isPlaying = ref(false);\n\n\nconst isSharing = computed(() => shareState?.value === 'active');\n\n\nwatch(\n  [screenStream, videoRef],\n  () => {\n    if (videoRef.value && screenStream?.value) {\n      videoRef.value.srcObject = screenStream.value;\n\n      \n      if (props.autoPlay) {\n        videoRef.value.play().catch((error) => {\n          console.warn('Auto-play failed:', error);\n        });\n      }\n    } else if (videoRef.value) {\n      videoRef.value.srcObject = null;\n    }\n  },\n  { immediate: true }\n);\n\n\nwatch(\n  [() => props.autoStart, isSharing],\n  async ([autoStart, sharing]) => {\n    if (autoStart && !sharing && startShare) {\n      try {\n        await startShare(props.options);\n      } catch (error) {\n        \n      }\n    }\n  },\n  { immediate: true }\n);\n\n\nconst handlePlay = () => {\n  isPlaying.value = true;\n  emit('playing');\n};\n\n\nconst handlePause = () => {\n  isPlaying.value = false;\n  emit('paused');\n};\n\n\nconst handleError = (event: Event) => {\n  emit('error', event);\n};\n\n\nonBeforeUnmount(() => {\n  if (videoRef.value) {\n    videoRef.value.srcObject = null;\n  }\n});\n</script>\n\n<template>\n  <video\n    ref=\"videoRef\"\n    :class=\"class\"\n    :autoplay=\"autoPlay\"\n    :muted=\"muted\"\n    :controls=\"controls\"\n    playsinline\n    @play=\"handlePlay\"\n    @pause=\"handlePause\"\n    @error=\"handleError\"\n  >\n    Your browser does not support the video element.\n  </video>\n</template>\n\n<style scoped>\nvideo {\n  max-width: 100%;\n  height: auto;\n}\n</style>\n"
      },
      {
        "name": "index.ts",
        "path": "registry/new-york/components/screen-share-provider/index.ts",
        "source": "\nimport type { InjectionKey, Ref } from 'vue';\nimport type {\n  ScreenShareType,\n  ScreenShareState,\n  ScreenShareStartFn,\n  ScreenShareStopFn,\n} from '~~/registry/new-york/composables/use-screen-share/useScreenShare';\n\nexport { default as ScreenShareProvider } from './ScreenShareProvider.vue';\nexport { default as ScreenShareViewer } from './ScreenShareViewer.vue';\n\nexport { type ScreenShareProviderProps } from './ScreenShareProvider.vue';\nexport { type ScreenShareViewerProps } from './ScreenShareViewer.vue';\n\n\nexport type {\n  ScreenShareType,\n  ScreenShareState,\n  ScreenShareOptions,\n  ScreenShareStartFn,\n  ScreenShareStopFn,\n} from '~~/registry/new-york/composables/use-screen-share/useScreenShare';\n\n\nexport interface ScreenShareProviderSlotProps {\n  \n  screenStream: MediaStream | null;\n  \n  shareState: ScreenShareState;\n  \n  shareType: ScreenShareType | null;\n  \n  errors: Error[];\n  \n  isSharing: boolean;\n  \n  startShare: ScreenShareStartFn;\n  \n  stopShare: ScreenShareStopFn;\n}\n\n\nexport const ScreenShareStreamKey: InjectionKey<Ref<MediaStream | null>> =\n  Symbol('ScreenShareStream');\n\nexport const ScreenShareStateKey: InjectionKey<Ref<ScreenShareState>> = Symbol('ScreenShareState');\n\nexport const ScreenShareTypeKey: InjectionKey<Ref<ScreenShareType | null>> =\n  Symbol('ScreenShareType');\n\nexport const ScreenShareErrorsKey: InjectionKey<Ref<Error[]>> = Symbol('ScreenShareErrors');\n\nexport const ScreenShareStartKey: InjectionKey<ScreenShareStartFn> = Symbol('ScreenShareStart');\n\nexport const ScreenShareStopKey: InjectionKey<ScreenShareStopFn> = Symbol('ScreenShareStop');\n"
      }
    ]
  },
  "simple-input": {
    "dependsOn": [],
    "usedBy": [],
    "files": [
      {
        "name": "SimpleInput.vue",
        "path": "registry/new-york/components/simple-input/SimpleInput.vue",
        "source": "<script lang=\"ts\">\n\n\nconst symKey = Symbol('symKey');\n\nexport default {\n  name: 'SimpleInput',\n  \n  props: {\n    \n    label: {\n      type: String,\n      required: false,\n      default: '',\n    },\n    \n    placeholder: {\n      type: String,\n      required: false,\n      default: '',\n    },\n    \n    modelValue: {\n      type: String,\n      required: false,\n      default: '',\n    },\n  },\n  emits: [\n    \n    'update:modelValue',\n  ],\n  inject: {\n    \n    injected: 'someKey',\n    \n    injectedSym: symKey,\n    \n    injectedSpread: 'spread',\n  },\n  provide() {\n    return {\n      \n      someOtherKey: 'providedValue',\n      \n      symKey: 'valSym',\n      \n      computedKey: true,\n    };\n  },\n  methods: {\n    onInput(event: Event) {\n      this.$emit('update:modelValue', (event.target as HTMLInputElement).value);\n    },\n  },\n  \n  expose: [\n    \n    'exposed',\n    \n    'other',\n    \n    'myFunc',\n  ],\n};\n</script>\n\n<template>\n  <div class=\"flex flex-col\">\n    <label v-if=\"label\">{{ label }}</label>\n    <input :placeholder=\"placeholder\" :value=\"modelValue\" @input=\"onInput\" type=\"text\" />\n  </div>\n</template>\n\n<style scoped>\n:root {\n  --input-border-color: #ccc;\n  --input-border-radius: 4px;\n  --input-padding: 0.5em 1em;\n  --input-font-size: 1em;\n}\n\ninput {\n  border: 1px solid #ccc;\n  border-radius: 4px;\n  padding: 0.5em 1em;\n  font-size: 1em;\n}\nlabel {\n  display: block;\n  margin-bottom: 0.25em;\n  font-weight: bold;\n}\n</style>\n"
      },
      {
        "name": "SimpleInputSetup.vue",
        "path": "registry/new-york/components/simple-input/SimpleInputSetup.vue",
        "source": "<script setup lang=\"ts\">\n\nimport { ref, inject, provide, defineExpose } from 'vue';\n\nconst props = defineProps({\n  \n  label: {\n    type: String,\n    required: false,\n    default: '',\n  },\n  \n  placeholder: {\n    type: String,\n    required: false,\n    default: '',\n  },\n  \n  modelValue: {\n    type: String,\n    required: false,\n    default: '',\n  },\n});\n\nconst emit = defineEmits<{\n  \n  (e: 'update:modelValue', value: string): void;\n}>();\n\nconst symKey = Symbol('symKey');\n\n\nconst injected = inject('someKey');\nconst injectedSym = inject(symKey);\nconst injectedSpread = inject('spread');\n\n\nprovide('someOtherKey', 'providedValue');\nprovide(symKey, 'valSym');\nprovide('computedKey', true);\n\n\nconst bar = ref('bar');\n\n\nfunction onInput(event: Event) {\n  emit('update:modelValue', (event.target as HTMLInputElement).value);\n}\n\n\nconst exposed = ref('exposed');\nconst other = ref('other');\nfunction myFunc() {\n  console.log('myFunc called');\n  return 'foo';\n}\ndefineExpose({ exposed, other, myFunc });\n</script>\n\n<template>\n  <label v-if=\"props.label\">{{ props.label }}</label>\n  <input :placeholder=\"props.placeholder\" :value=\"props.modelValue\" @input=\"onInput\" type=\"text\" />\n</template>\n\n<style scoped>\n:root {\n  --input-border-color: #ccc;\n  --input-border-radius: 4px;\n  --input-padding: 0.5em 1em;\n  --input-font-size: 1em;\n}\n\ninput {\n  border: 1px solid #ccc;\n  border-radius: 4px;\n  padding: 0.5em 1em;\n  font-size: 1em;\n}\nlabel {\n  display: block;\n  margin-bottom: 0.25em;\n  font-weight: bold;\n}\n</style>\n"
      },
      {
        "name": "index.ts",
        "path": "registry/new-york/components/simple-input/index.ts",
        "source": "\n\nexport { default as SimpleInput } from './SimpleInput.vue';\nexport { default as SimpleInputSetup } from './SimpleInputSetup.vue';\n"
      }
    ]
  },
  "use-control-registry": {
    "dependsOn": [
      {
        "path": "components/control-grid",
        "files": [
          "ControlGrid.old.vue",
          "ControlGrid.vue",
          "ControlGridItem.vue",
          "ControlGridToolbar.vue",
          "index.ts"
        ]
      }
    ],
    "usedBy": [
      "control-grid"
    ],
    "files": [
      {
        "name": "useControlRegistry.ts",
        "path": "registry/new-york/composables/use-control-registry/useControlRegistry.ts",
        "source": "\n\nimport { ref, shallowRef, type Component } from 'vue';\nimport type { GridItem, GridItemTemplate } from '../../components/control-grid';\n\nexport interface ControlDefinition {\n  id: string;\n  name: string;\n  description?: string;\n  component: Component;\n  defaultProps?: Record<string, any>;\n  defaultSize?: {\n    width: number;\n    height: number;\n  };\n  category?: string;\n  icon?: string;\n  color?: string;\n  \n  label?: string;\n}\n\nexport interface ControlInstance {\n  id: string;\n  controlId: string;\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  component: Component;\n  props?: Record<string, any>;\n  color?: string;\n}\n\nconst registeredControls = ref<Map<string, ControlDefinition>>(new Map());\nconst itemCounter = ref(0);\n\nexport function useControlRegistry() {\n  \n  const registerControl = (\n    definition: ControlDefinition | Component,\n    options?: Partial<Omit<ControlDefinition, 'component'>>\n  ) => {\n    let controlDef: ControlDefinition;\n\n    \n    if ((typeof definition === 'object' && 'setup' in definition) || 'render' in definition) {\n      if (!options?.id) {\n        console.error(\"Un ID est requis lors de l'enregistrement d'un composant brut\");\n        return;\n      }\n\n      controlDef = {\n        id: options.id,\n        name: options.name || options.id,\n        description: options.description,\n        component: definition as Component,\n        defaultProps: options.defaultProps,\n        defaultSize: options.defaultSize || { width: 1, height: 1 },\n        category: options.category,\n        icon: options.icon,\n        color: options.color,\n        label: options.label || options.name || options.id,\n      };\n    } else {\n      \n      controlDef = definition as ControlDefinition;\n    }\n\n    if (registeredControls.value.has(controlDef.id)) {\n      console.warn(`Control with id \"${controlDef.id}\" is already registered. Overwriting.`);\n    }\n\n    registeredControls.value.set(controlDef.id, {\n      ...controlDef,\n      component: shallowRef(controlDef.component),\n      label: controlDef.label || controlDef.name,\n    });\n  };\n\n  \n  const registerControls = (definitions: (ControlDefinition | Component)[]) => {\n    definitions.forEach((def) => {\n      if ('id' in def) {\n        registerControl(def);\n      } else {\n        console.warn(\n          \"Impossible d'enregistrer un composant brut sans options. Utilisez registerControl avec options.\"\n        );\n      }\n    });\n  };\n\n  \n  const registerControlFromFile = async (\n    filePath: string,\n    options: Partial<Omit<ControlDefinition, 'component'>> & { id: string }\n  ): Promise<boolean> => {\n    try {\n      \n      const module = await import( filePath);\n      const component = module.default || module;\n\n      if (!component) {\n        console.error(`Aucun composant trouvé dans ${filePath}`);\n        return false;\n      }\n\n      registerControl(component, options);\n      return true;\n    } catch (error) {\n      console.error(`Erreur lors du chargement du composant depuis ${filePath}:`, error);\n      return false;\n    }\n  };\n\n  \n  const getControl = (id: string): ControlDefinition | undefined => {\n    return registeredControls.value.get(id);\n  };\n\n  \n  const getAllControls = (): ControlDefinition[] => {\n    return Array.from(registeredControls.value.values());\n  };\n\n  \n  const getControlsByCategory = (category: string): ControlDefinition[] => {\n    return getAllControls().filter((control) => control.category === category);\n  };\n\n  \n  const createControlInstance = (\n    controlId: string,\n    position?: { x: number; y: number },\n    customProps?: Record<string, any>\n  ): Partial<ControlInstance> | null => {\n    const control = getControl(controlId);\n    if (!control) {\n      console.error(`Control with id \"${controlId}\" not found in registry`);\n      return null;\n    }\n\n    itemCounter.value++;\n    const instanceId = `${controlId}-${itemCounter.value}`;\n\n    return {\n      id: instanceId,\n      controlId: control.id,\n      x: position?.x ?? 0,\n      y: position?.y ?? 0,\n      width: control.defaultSize?.width ?? 1,\n      height: control.defaultSize?.height ?? 1,\n      component: control.component,\n      props: {\n        ...control.defaultProps,\n        ...customProps,\n        id: instanceId,\n      },\n      color: customProps?.color ?? control.color,\n    };\n  };\n\n  \n  const createItemFromControl = (controlId: string): Omit<GridItem, 'x' | 'y'> | null => {\n    const control = getControl(controlId);\n    if (!control) {\n      console.error(`Control with id \"${controlId}\" not found in registry`);\n      return null;\n    }\n\n    itemCounter.value++;\n    const instanceId = `${controlId}-${itemCounter.value}`;\n\n    return {\n      id: instanceId,\n      width: control.defaultSize?.width ?? 1,\n      height: control.defaultSize?.height ?? 1,\n      component: control.component,\n      color: control.color,\n      ...control.defaultProps,\n    };\n  };\n\n  \n  const controlToTemplate = (controlId: string): GridItemTemplate | null => {\n    const control = getControl(controlId);\n    if (!control) {\n      console.error(`Control with id \"${controlId}\" not found in registry`);\n      return null;\n    }\n\n    return {\n      id: control.id,\n      width: control.defaultSize?.width ?? 1,\n      height: control.defaultSize?.height ?? 1,\n      component: control.component,\n      color: control.color,\n      label: control.label || control.name,\n      icon: control.icon,\n      ...control.defaultProps,\n    };\n  };\n\n  \n  const getAllTemplates = (): GridItemTemplate[] => {\n    return getAllControls().map((control) => ({\n      id: control.id,\n      width: control.defaultSize?.width ?? 1,\n      height: control.defaultSize?.height ?? 1,\n      component: control.component,\n      color: control.color,\n      label: control.label || control.name,\n      icon: control.icon,\n      ...control.defaultProps,\n    }));\n  };\n\n  \n  const filterTemplatesBySize = (maxWidth: number, maxHeight: number): GridItemTemplate[] => {\n    return getAllTemplates().filter(\n      (template) => template.width <= maxWidth && template.height <= maxHeight\n    );\n  };\n\n  \n  const unregisterControl = (id: string): boolean => {\n    return registeredControls.value.delete(id);\n  };\n\n  \n  const clearRegistry = () => {\n    registeredControls.value.clear();\n  };\n\n  \n  const hasControl = (id: string): boolean => {\n    return registeredControls.value.has(id);\n  };\n\n  return {\n    \n    registerControl,\n    registerControls,\n    registerControlFromFile,\n\n    \n    getControl,\n    getAllControls,\n    getControlsByCategory,\n    hasControl,\n\n    \n    createControlInstance,\n    createItemFromControl,\n\n    \n    controlToTemplate,\n    getAllTemplates,\n    filterTemplatesBySize,\n\n    \n    unregisterControl,\n    clearRegistry,\n  };\n}\n"
      }
    ]
  },
  "use-controls-grid": {
    "dependsOn": [
      {
        "path": "components/control-grid",
        "files": [
          "ControlGrid.old.vue",
          "ControlGrid.vue",
          "ControlGridItem.vue",
          "ControlGridToolbar.vue",
          "index.ts"
        ]
      }
    ],
    "usedBy": [],
    "files": [
      {
        "name": "useControlsGrid.ts",
        "path": "registry/new-york/composables/use-controls-grid/useControlsGrid.ts",
        "source": "\n\nimport { ref, computed } from 'vue';\nimport type { GridItem } from '../../components/control-grid';\nimport { GridUtils } from '../../components/control-grid';\n\nexport function useControlsGrid(initialItems: GridItem[] = []) {\n  \n  const items = ref<GridItem[]>([...initialItems]);\n  const selectedItemId = ref<string | null>(null);\n  const history = ref<GridItem[][]>([]);\n  const historyIndex = ref(-1);\n  const maxHistorySize = 50;\n\n  \n  const selectedItem = computed(() => {\n    if (!selectedItemId.value) return null;\n    return items.value.find((item) => item.id === selectedItemId.value) || null;\n  });\n\n  const canUndo = computed(() => historyIndex.value > 0);\n  const canRedo = computed(() => historyIndex.value < history.value.length - 1);\n\n  const totalArea = computed(() => {\n    return items.value.reduce((sum, item) => sum + GridUtils.calculateArea(item), 0);\n  });\n\n  \n  const addToHistory = () => {\n    \n    history.value = history.value.slice(0, historyIndex.value + 1);\n\n    \n    history.value.push(JSON.parse(JSON.stringify(items.value)));\n\n    \n    if (history.value.length > maxHistorySize) {\n      history.value.shift();\n    } else {\n      historyIndex.value++;\n    }\n  };\n\n  const undo = () => {\n    if (!canUndo.value) return;\n\n    historyIndex.value--;\n    items.value = JSON.parse(JSON.stringify(history.value[historyIndex.value]));\n  };\n\n  const redo = () => {\n    if (!canRedo.value) return;\n\n    historyIndex.value++;\n    items.value = JSON.parse(JSON.stringify(history.value[historyIndex.value]));\n  };\n\n  const addItem = (item: GridItem) => {\n    items.value.push(item);\n    addToHistory();\n  };\n\n  const removeItem = (id: string) => {\n    const index = items.value.findIndex((item) => item.id === id);\n    if (index !== -1) {\n      items.value.splice(index, 1);\n      if (selectedItemId.value === id) {\n        selectedItemId.value = null;\n      }\n      addToHistory();\n    }\n  };\n\n  const updateItem = (id: string, updates: Partial<GridItem>) => {\n    const index = items.value.findIndex((item) => item.id === id);\n    if (index !== -1) {\n      items.value[index] = { ...items.value[index], ...updates } as GridItem;\n      addToHistory();\n    }\n  };\n\n  const clearItems = () => {\n    items.value = [];\n    selectedItemId.value = null;\n    addToHistory();\n  };\n\n  const selectItem = (id: string | null) => {\n    selectedItemId.value = id;\n  };\n\n  const duplicateItem = (id: string, offsetX = 1, offsetY = 0) => {\n    const item = items.value.find((item) => item.id === id);\n    if (!item) return null;\n\n    const newItem = GridUtils.cloneItemAtPosition(item, item.x + offsetX, item.y + offsetY);\n\n    items.value.push(newItem);\n    addToHistory();\n\n    return newItem;\n  };\n\n  const exportConfig = () => {\n    return {\n      items: items.value,\n      timestamp: new Date().toISOString(),\n      version: '1.0.0',\n    };\n  };\n\n  const importConfig = (config: { items: GridItem[] }) => {\n    items.value = config.items;\n    selectedItemId.value = null;\n    addToHistory();\n  };\n\n  const saveToLocalStorage = (key = 'controls-grid-config') => {\n    try {\n      localStorage.setItem(key, JSON.stringify(exportConfig()));\n      return true;\n    } catch (error) {\n      console.error('Failed to save to localStorage:', error);\n      return false;\n    }\n  };\n\n  const loadFromLocalStorage = (key = 'controls-grid-config') => {\n    try {\n      const data = localStorage.getItem(key);\n      if (data) {\n        const config = JSON.parse(data);\n        importConfig(config);\n        return true;\n      }\n      return false;\n    } catch (error) {\n      console.error('Failed to load from localStorage:', error);\n      return false;\n    }\n  };\n\n  const sortItems = () => {\n    items.value = GridUtils.sortItems(items.value);\n  };\n\n  const getItemById = (id: string) => {\n    return items.value.find((item) => item.id === id);\n  };\n\n  const getItemsAtPosition = (x: number, y: number) => {\n    return items.value.filter(\n      (item) => x >= item.x && x < item.x + item.width && y >= item.y && y < item.y + item.height\n    );\n  };\n\n  \n  if (items.value.length > 0) {\n    addToHistory();\n  }\n\n  return {\n    \n    items,\n    selectedItemId,\n    selectedItem,\n    canUndo,\n    canRedo,\n    totalArea,\n\n    \n    addItem,\n    removeItem,\n    updateItem,\n    clearItems,\n    selectItem,\n    duplicateItem,\n    undo,\n    redo,\n    exportConfig,\n    importConfig,\n    saveToLocalStorage,\n    loadFromLocalStorage,\n    sortItems,\n    getItemById,\n    getItemsAtPosition,\n  };\n}\n"
      }
    ]
  },
  "use-drag-drop": {
    "dependsOn": [],
    "usedBy": [
      "control-grid",
      "drag-drop-provider",
      "use-drag-drop-context"
    ],
    "files": [
      {
        "name": "useDragDrop.ts",
        "path": "registry/new-york/composables/use-drag-drop/useDragDrop.ts",
        "source": "\n\nimport { ref, computed, type Ref, onMounted } from 'vue';\nimport { useElementBounding } from '@vueuse/core';\n\nexport interface DragDropItem<T = any> {\n  \n  id: string;\n  \n  width: number;\n  \n  height: number;\n  \n  data?: T;\n}\n\nexport interface DragDropPosition {\n  \n  x: number;\n  \n  y: number;\n}\n\nexport interface DragDropBounds {\n  left: number;\n  top: number;\n  right: number;\n  bottom: number;\n  width: number;\n  height: number;\n}\n\nexport interface DragDropState<T = any> {\n  \n  item: DragDropItem<T> | null;\n  \n  fromContainer: boolean;\n  \n  hoverPosition: DragDropPosition | null;\n  \n  isValid: boolean;\n  \n  isDragging: boolean;\n}\n\nexport interface UseDragDropOptions {\n  \n  containerRef?: Ref<HTMLElement | null>;\n  \n  unitSize?: number;\n  \n  gap?: number;\n  \n  allowCollision?: boolean;\n  \n  validatePlacement?: (\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    excludeId?: string\n  ) => boolean;\n}\n\nexport interface UseDragDropReturn<T = any> {\n  \n  dragState: Ref<DragDropState<T>>;\n  \n  dragOffset: Ref<{ x: number; y: number } | null>;\n  \n  containerBounds?: ReturnType<typeof useElementBounding>;\n  \n  startDrag: (event: DragEvent, item: DragDropItem<T>, fromContainer?: boolean) => void;\n  \n  handleDragOver: (\n    event: DragEvent,\n    containerBounds: DragDropBounds,\n    getPosition: (bounds: DragDropBounds) => DragDropPosition | null\n  ) => DragDropPosition | null;\n  \n  handleDragOverSimple?: (\n    event: DragEvent,\n    getPosition: (\n      virtualBounds: DragDropBounds,\n      containerBounds: DragDropBounds\n    ) => DragDropPosition | null\n  ) => DragDropPosition | null;\n  \n  endDrag: () => void;\n  \n  getVirtualBounds: (clientX: number, clientY: number) => DragDropBounds | null;\n  \n  getItemFromDataTransfer: (dataTransfer: DataTransfer | null) => DragDropItem<T> | null;\n}\n\n\nexport function useDragDrop<T = any>(options: UseDragDropOptions): UseDragDropReturn<T> {\n  const { containerRef, unitSize, gap = 0, allowCollision = false, validatePlacement } = options;\n\n  \n  const dragState = ref<DragDropState<T>>({\n    item: null,\n    fromContainer: false,\n    hoverPosition: null,\n    isValid: false,\n    isDragging: false,\n  }) as Ref<DragDropState<T>>;\n\n  \n  const dragOffset = ref<{ x: number; y: number } | null>(null);\n\n  \n  \n  const containerBounds = containerRef ? useElementBounding(containerRef) : undefined;\n\n  \n  const startDrag = (event: DragEvent, item: DragDropItem<T>, fromContainer = false) => {\n    dragState.value.item = { ...item };\n    dragState.value.fromContainer = fromContainer;\n    dragState.value.isDragging = true;\n\n    \n    if (event.target instanceof HTMLElement) {\n      const targetRect = event.target.getBoundingClientRect();\n\n      \n      const offsetX = event.clientX - targetRect.left;\n      const offsetY = event.clientY - targetRect.top;\n\n      dragOffset.value = { x: offsetX, y: offsetY };\n    }\n\n    if (event.dataTransfer) {\n      event.dataTransfer.effectAllowed = 'move';\n      event.dataTransfer.setData('application/json', JSON.stringify(item));\n    }\n  };\n\n  \n  const getVirtualBounds = (clientX: number, clientY: number): DragDropBounds | null => {\n    if (!dragState.value.item) return null;\n\n    \n    \n    const itemWidth =\n      unitSize !== undefined\n        ? dragState.value.item.width * (unitSize + gap) - gap\n        : dragState.value.item.width; \n    const itemHeight =\n      unitSize !== undefined\n        ? dragState.value.item.height * (unitSize + gap) - gap\n        : dragState.value.item.height; \n\n    \n    const offsetX = dragOffset.value?.x ?? itemWidth / 2;\n    const offsetY = dragOffset.value?.y ?? itemHeight / 2;\n\n    return {\n      left: clientX - offsetX,\n      top: clientY - offsetY,\n      right: clientX - offsetX + itemWidth,\n      bottom: clientY - offsetY + itemHeight,\n      width: itemWidth,\n      height: itemHeight,\n    };\n  };\n\n  \n  const getItemFromDataTransfer = (dataTransfer: DataTransfer | null): DragDropItem<T> | null => {\n    if (!dataTransfer) return null;\n\n    try {\n      const data = dataTransfer.getData('application/json');\n      if (data) {\n        return JSON.parse(data) as DragDropItem<T>;\n      }\n    } catch (e) {\n      console.error('Erreur lors du parsing des données de drag:', e);\n    }\n\n    return null;\n  };\n\n  \n  const handleDragOver = (\n    event: DragEvent,\n    containerBounds: DragDropBounds,\n    getPosition: (bounds: DragDropBounds) => DragDropPosition | null\n  ): DragDropPosition | null => {\n    event.preventDefault();\n\n    if (!dragState.value.item) {\n      \n      const item = getItemFromDataTransfer(event.dataTransfer);\n      if (item) {\n        dragState.value.item = item;\n      }\n    }\n\n    if (event.dataTransfer) {\n      const effect = event.dataTransfer.effectAllowed;\n      if (effect === 'copy' || effect === 'copyMove') {\n        event.dataTransfer.dropEffect = 'copy';\n      } else {\n        event.dataTransfer.dropEffect = 'move';\n      }\n    }\n\n    \n    const virtualBounds = getVirtualBounds(event.clientX, event.clientY);\n    if (!virtualBounds) return null;\n\n    \n    const pos = getPosition(virtualBounds);\n    if (!pos) return null;\n\n    \n    if (!allowCollision && validatePlacement && dragState.value.item) {\n      const excludeId = dragState.value.fromContainer ? dragState.value.item.id : undefined;\n      const isValid = validatePlacement(\n        pos.x,\n        pos.y,\n        dragState.value.item.width,\n        dragState.value.item.height,\n        excludeId\n      );\n\n      dragState.value.hoverPosition = pos;\n      dragState.value.isValid = isValid;\n\n      if (!isValid && event.dataTransfer) {\n        event.dataTransfer.dropEffect = 'none';\n      }\n    } else {\n      dragState.value.hoverPosition = pos;\n      dragState.value.isValid = true;\n    }\n\n    return pos;\n  };\n\n  \n  const endDrag = () => {\n    dragState.value.item = null;\n    dragState.value.fromContainer = false;\n    dragState.value.hoverPosition = null;\n    dragState.value.isValid = false;\n    dragState.value.isDragging = false;\n    dragOffset.value = null;\n  };\n\n  \n  const handleDragOverSimple = containerBounds\n    ? (\n        event: DragEvent,\n        getPosition: (\n          virtualBounds: DragDropBounds,\n          containerBounds: DragDropBounds\n        ) => DragDropPosition | null\n      ): DragDropPosition | null => {\n        const bounds: DragDropBounds = {\n          left: containerBounds.left.value,\n          top: containerBounds.top.value,\n          right: containerBounds.right.value,\n          bottom: containerBounds.bottom.value,\n          width: containerBounds.width.value,\n          height: containerBounds.height.value,\n        };\n        return handleDragOver(event, bounds, (virtualBounds) => getPosition(virtualBounds, bounds));\n      }\n    : undefined;\n\n  const returnValue: UseDragDropReturn<T> = {\n    dragState,\n    dragOffset,\n    startDrag,\n    handleDragOver,\n    endDrag,\n    getVirtualBounds,\n    getItemFromDataTransfer,\n  };\n\n  \n  if (containerBounds) {\n    returnValue.containerBounds = containerBounds;\n    returnValue.handleDragOverSimple = handleDragOverSimple;\n  }\n\n  return returnValue;\n}\n\n\nexport class DragDropUtils {\n  \n  static getPositionByIntersection(\n    elementBounds: DragDropBounds,\n    containerBounds: DragDropBounds,\n    unitSize: number,\n    gap: number,\n    columns: number,\n    rows: number\n  ): DragDropPosition | null {\n    let maxIntersectionArea = 0;\n    let bestPosition = { x: 0, y: 0 };\n\n    \n    const startX = Math.max(\n      0,\n      Math.floor((elementBounds.left - containerBounds.left - gap) / (unitSize + gap))\n    );\n    const endX = Math.min(\n      columns - 1,\n      Math.ceil((elementBounds.right - containerBounds.left - gap) / (unitSize + gap))\n    );\n    const startY = Math.max(\n      0,\n      Math.floor((elementBounds.top - containerBounds.top - gap) / (unitSize + gap))\n    );\n    const endY = Math.min(\n      rows - 1,\n      Math.ceil((elementBounds.bottom - containerBounds.top - gap) / (unitSize + gap))\n    );\n\n    for (let y = startY; y <= endY; y++) {\n      for (let x = startX; x <= endX; x++) {\n        \n        const cellLeft = containerBounds.left + gap + x * (unitSize + gap);\n        const cellTop = containerBounds.top + gap + y * (unitSize + gap);\n        const cellRight = cellLeft + unitSize;\n        const cellBottom = cellTop + unitSize;\n\n        \n        const intersectionLeft = Math.max(elementBounds.left, cellLeft);\n        const intersectionTop = Math.max(elementBounds.top, cellTop);\n        const intersectionRight = Math.min(elementBounds.right, cellRight);\n        const intersectionBottom = Math.min(elementBounds.bottom, cellBottom);\n\n        \n        const intersectionWidth = Math.max(0, intersectionRight - intersectionLeft);\n        const intersectionHeight = Math.max(0, intersectionBottom - intersectionTop);\n        const intersectionArea = intersectionWidth * intersectionHeight;\n\n        if (intersectionArea > maxIntersectionArea) {\n          maxIntersectionArea = intersectionArea;\n          bestPosition = { x, y };\n        }\n      }\n    }\n\n    \n    return maxIntersectionArea > 0 ? bestPosition : null;\n  }\n\n  \n  static pixelToGrid(\n    pixelX: number,\n    pixelY: number,\n    unitSize: number,\n    gap: number\n  ): DragDropPosition {\n    const x = Math.floor(pixelX / (unitSize + gap));\n    const y = Math.floor(pixelY / (unitSize + gap));\n    return { x, y };\n  }\n\n  \n  static gridToPixel(\n    gridX: number,\n    gridY: number,\n    unitSize: number,\n    gap: number\n  ): { x: number; y: number } {\n    const x = gridX * (unitSize + gap);\n    const y = gridY * (unitSize + gap);\n    return { x, y };\n  }\n}\n"
      }
    ]
  },
  "use-drag-drop-context": {
    "dependsOn": [
      {
        "path": "composables/use-drag-drop",
        "files": [
          "useDragDrop.ts"
        ]
      }
    ],
    "usedBy": [
      "drag-drop-provider"
    ],
    "files": [
      {
        "name": "useDragDropContext.ts",
        "path": "registry/new-york/composables/use-drag-drop-context/useDragDropContext.ts",
        "source": "\n\nimport { inject } from 'vue';\nimport type { UseDragDropReturn, UseDragDropOptions } from '../use-drag-drop/useDragDrop';\n\n\nexport const DRAG_DROP_INJECTION_KEY = Symbol('drag-drop-context');\n\nexport interface DragDropContext<T = any> extends UseDragDropReturn<T> {\n  options: Readonly<UseDragDropOptions & { mode?: 'drag' | 'resize' | 'both' }>;\n}\n\n\nexport function useDragDropContext<T = any>(): DragDropContext<T> {\n  const context = inject<DragDropContext<T>>(DRAG_DROP_INJECTION_KEY);\n\n  if (!context) {\n    throw new Error(\n      'useDragDropContext must be used within a DragDropProvider component. ' +\n        'Make sure to wrap your component with <DragDropProvider>.'\n    );\n  }\n\n  return context;\n}\n\n\nexport function useDragDropContextOptional<T = any>(): DragDropContext<T> | undefined {\n  return inject<DragDropContext<T> | undefined>(DRAG_DROP_INJECTION_KEY, undefined);\n}\n"
      }
    ]
  },
  "use-media-devices": {
    "dependsOn": [
      {
        "path": "composables/use-media-devices",
        "files": [
          "foo.ts",
          "useMediaDevices.ts"
        ]
      }
    ],
    "usedBy": [
      "media-devices-provider",
      "use-media-devices"
    ],
    "files": [
      {
        "name": "index.ts",
        "path": "registry/new-york/composables/use-media-devices/bar/index.ts",
        "source": "export const bar = 'foo';\n"
      },
      {
        "name": "foo.ts",
        "path": "registry/new-york/composables/use-media-devices/foo.ts",
        "source": "import { bar } from './bar';\n\nexport const foo = 'bar';\n"
      },
      {
        "name": "useMediaDevices.ts",
        "path": "registry/new-york/composables/use-media-devices/useMediaDevices.ts",
        "source": "\n\nimport { ref, computed, onBeforeUnmount, watch, toRef, type MaybeRef } from 'vue';\nimport { useEventListener } from '@vueuse/core';\n\n\nimport { foo } from './foo';\nimport { bar } from './bar';\n\n\nexport type MediaDeviceType = 'camera' | 'microphone' | 'all';\n\n\nexport type MediaDeviceKind = 'videoinput' | 'audioinput' | 'audiooutput';\n\n\nexport type MediaPermissionState = 'granted' | 'denied' | 'prompt' | 'unknown';\n\n\nexport interface MediaPermissions {\n  camera: MediaPermissionState;\n  microphone: MediaPermissionState;\n}\n\n\nexport type MediaDevicesStartFn = (\n  deviceId: string,\n  constraints: MediaStreamConstraints\n) => Promise<MediaStream>;\n\n\nexport type MediaDevicesStopFn = (deviceId: string) => void;\n\n\nexport type MediaDevicesStopAllFn = () => void;\n\n\nexport interface UseMediaDevicesOptions {\n  \n  type?: MaybeRef<MediaDeviceType>;\n  \n  open?: MaybeRef<boolean>;\n  \n  onStreamStarted?: (deviceId: string, stream: MediaStream) => void;\n  \n  onStreamStopped?: (deviceId: string) => void;\n  \n  onAllStreamsStopped?: () => void;\n  \n  onDevicesUpdated?: (devices: MediaDeviceInfo[]) => void;\n  \n  onError?: (error: Error) => void;\n}\n\nexport function useMediaDevices(options: UseMediaDevicesOptions = {}) {\n  const { onStreamStarted, onStreamStopped, onAllStreamsStopped, onDevicesUpdated, onError } =\n    options;\n\n  \n  const type = toRef(options.type ?? 'all');\n  const open = toRef(options.open ?? false);\n\n  \n  const devices = ref<MediaDeviceInfo[]>([]);\n\n  \n  const errors = ref<Error[]>([]);\n\n  \n  const isLoading = ref<boolean>(false);\n\n  \n  const permissions = ref<MediaPermissions>({\n    camera: 'unknown',\n    microphone: 'unknown',\n  });\n\n  \n  const activeStreams = ref<Map<string, MediaStream>>(new Map());\n\n  \n  const filterDevicesByKind = (kind: MediaDeviceKind): MediaDeviceInfo[] => {\n    return devices.value.filter((d) => d.kind === kind);\n  };\n\n  \n  const cameras = computed(() => filterDevicesByKind('videoinput'));\n  const microphones = computed(() => filterDevicesByKind('audioinput'));\n  const speakers = computed(() => filterDevicesByKind('audiooutput'));\n\n  \n  const readonlyActiveStreams = computed(\n    () => activeStreams.value as ReadonlyMap<string, MediaStream>\n  );\n\n  \n  const checkPermission = async (name: 'camera' | 'microphone'): Promise<MediaPermissionState> => {\n    if (typeof navigator === 'undefined' || !navigator.permissions) {\n      return 'unknown';\n    }\n\n    try {\n      const permissionName = name === 'camera' ? 'camera' : 'microphone';\n      const result = await navigator.permissions.query({ name: permissionName as PermissionName });\n      return result.state as MediaPermissionState;\n    } catch (error) {\n      \n      return 'unknown';\n    }\n  };\n\n  \n  const updatePermissions = async () => {\n    permissions.value.camera = await checkPermission('camera');\n    permissions.value.microphone = await checkPermission('microphone');\n  };\n\n  \n  const startStream: MediaDevicesStartFn = async (\n    deviceId: string,\n    constraints: MediaStreamConstraints\n  ): Promise<MediaStream> => {\n    \n    const existingStream = activeStreams.value.get(deviceId);\n    if (existingStream?.active) {\n      return existingStream;\n    }\n\n    \n    if (existingStream) {\n      activeStreams.value.delete(deviceId);\n    }\n\n    try {\n      \n      if (typeof navigator === 'undefined' || !navigator.mediaDevices) {\n        throw new Error('navigator.mediaDevices not available (SSR or unsupported browser)');\n      }\n\n      const stream = await navigator.mediaDevices.getUserMedia(constraints);\n\n      activeStreams.value.set(deviceId, stream);\n      onStreamStarted?.(deviceId, stream);\n      return stream;\n    } catch (error) {\n      const err = error as Error;\n      errors.value.push(err);\n      onError?.(err);\n      throw error;\n    }\n  };\n\n  \n  const stopStream: MediaDevicesStopFn = (deviceId: string) => {\n    const stream = activeStreams.value.get(deviceId);\n    if (stream) {\n      stream.getTracks().forEach((track) => track.stop());\n      activeStreams.value.delete(deviceId);\n      onStreamStopped?.(deviceId);\n    }\n  };\n\n  \n  const stopAllStreams: MediaDevicesStopAllFn = () => {\n    activeStreams.value.forEach((stream, _deviceId) => {\n      stream.getTracks().forEach((track) => track.stop());\n    });\n    activeStreams.value.clear();\n    onAllStreamsStopped?.();\n  };\n\n  \n  const updateAvailableDevices = async () => {\n    if (\n      typeof navigator === 'undefined' ||\n      !navigator.mediaDevices ||\n      !navigator.mediaDevices.enumerateDevices\n    ) {\n      devices.value = [];\n      return;\n    }\n\n    isLoading.value = true;\n    try {\n      devices.value = await navigator.mediaDevices.enumerateDevices();\n      onDevicesUpdated?.(devices.value);\n    } catch (error) {\n      const err = error as Error;\n      errors.value.push(err);\n      onError?.(err);\n    } finally {\n      isLoading.value = false;\n    }\n  };\n\n  \n  const requestMediaIfNeeded = async () => {\n    \n    if (typeof navigator === 'undefined' || !navigator.mediaDevices) {\n      return;\n    }\n\n    const needsVideo = type.value === 'camera' || type.value === 'all';\n    const needsAudio = type.value === 'microphone' || type.value === 'all';\n\n    try {\n      \n      \n      \n      const stream = await navigator.mediaDevices.getUserMedia({\n        video: needsVideo,\n        audio: needsAudio,\n      });\n      \n      \n      stream.getTracks().forEach((track) => track.stop());\n\n      \n      await updatePermissions();\n    } catch (error) {\n      const err = error as Error;\n      errors.value.push(err);\n      onError?.(err);\n\n      \n      await updatePermissions();\n    }\n  };\n\n  \n  const ensurePermissions = async () => {\n    if (open.value) {\n      await requestMediaIfNeeded();\n    }\n  };\n\n  \n  const initialize = async () => {\n    \n    await updatePermissions();\n\n    if (open.value) {\n      await ensurePermissions();\n      \n      await new Promise((resolve) => setTimeout(resolve, 100));\n      await updateAvailableDevices();\n    }\n  };\n\n  \n  watch([type, open], async ([newType, newOpen], [oldType, oldOpen]) => {\n    \n    if (newOpen && !oldOpen) {\n      await ensurePermissions();\n      await updateAvailableDevices();\n    }\n    \n    else if (!newOpen && oldOpen) {\n      stopAllStreams();\n    }\n    \n    else if (newOpen && newType !== oldType) {\n      \n      \n      const shouldStopAll =\n        oldType === 'all' || \n        (oldType === 'camera' && newType === 'microphone') || \n        (oldType === 'microphone' && newType === 'camera'); \n\n      if (shouldStopAll) {\n        stopAllStreams();\n      }\n\n      await ensurePermissions();\n      await updateAvailableDevices();\n    }\n  });\n\n  \n  if (typeof navigator !== 'undefined' && navigator.mediaDevices) {\n    useEventListener(navigator.mediaDevices, 'devicechange', updateAvailableDevices);\n  }\n\n  \n  onBeforeUnmount(() => {\n    stopAllStreams();\n  });\n\n  \n  return {\n    \n    devices,\n    \n    cameras,\n    \n    microphones,\n    \n    speakers,\n    \n    errors,\n    \n    isLoading,\n    \n    permissions,\n    \n    activeStreams: readonlyActiveStreams,\n    \n    startStream,\n    \n    stopStream,\n    \n    stopAllStreams,\n    \n    updateAvailableDevices,\n    \n    ensurePermissions,\n    \n    initialize,\n  };\n}\n"
      }
    ]
  },
  "use-screen-share": {
    "dependsOn": [],
    "usedBy": [
      "screen-share-provider"
    ],
    "files": [
      {
        "name": "useScreenShare.ts",
        "path": "registry/new-york/composables/use-screen-share/useScreenShare.ts",
        "source": "\n\nimport { ref, computed, onBeforeUnmount } from 'vue';\n\n\nexport type ScreenShareType = 'monitor' | 'window' | 'browser';\n\n\nexport type ScreenShareState = 'idle' | 'requesting' | 'active' | 'error';\n\n\nexport interface ScreenShareOptions {\n  \n  video?: boolean | MediaTrackConstraints;\n  \n  audio?: boolean | MediaTrackConstraints;\n  \n  preferCurrentTab?: boolean;\n  \n  surfaceSwitching?: 'include' | 'exclude';\n  \n  selfBrowserSurface?: 'include' | 'exclude';\n  \n  systemAudio?: 'include' | 'exclude';\n}\n\n\nexport type ScreenShareStartFn = (options?: ScreenShareOptions) => Promise<MediaStream>;\n\n\nexport type ScreenShareStopFn = () => void;\n\nexport interface UseScreenShareOptions {\n  \n  defaultOptions?: ScreenShareOptions;\n  \n  onShareStarted?: (stream: MediaStream) => void;\n  \n  onShareStopped?: () => void;\n  \n  onError?: (error: Error) => void;\n}\n\nexport function useScreenShare(options: UseScreenShareOptions = {}) {\n  const { defaultOptions, onShareStarted, onShareStopped, onError } = options;\n\n  \n  const screenStream = ref<MediaStream | null>(null);\n\n  \n  const shareState = ref<ScreenShareState>('idle');\n\n  \n  const shareType = ref<ScreenShareType | null>(null);\n\n  \n  const errors = ref<Error[]>([]);\n\n  \n  const isSharing = computed(() => shareState.value === 'active');\n\n  \n  const detectShareType = (stream: MediaStream) => {\n    try {\n      const videoTrack = stream.getVideoTracks()[0];\n      if (!videoTrack) return;\n\n      const settings = videoTrack.getSettings();\n      \n      if ('displaySurface' in settings) {\n        shareType.value = settings.displaySurface as ScreenShareType;\n      }\n    } catch (error) {\n      \n      console.warn('Could not detect share type:', error);\n    }\n  };\n\n  \n  const handleStreamEnded = () => {\n    screenStream.value = null;\n    shareState.value = 'idle';\n    shareType.value = null;\n    onShareStopped?.();\n  };\n\n  \n  const startScreenShare: ScreenShareStartFn = async (options = {}) => {\n    \n    if (screenStream.value?.active) {\n      return screenStream.value;\n    }\n\n    \n    if (typeof navigator === 'undefined' || !navigator.mediaDevices?.getDisplayMedia) {\n      const error = new Error('getDisplayMedia not available (SSR or unsupported browser)');\n      errors.value.push(error);\n      onError?.(error);\n      throw error;\n    }\n\n    shareState.value = 'requesting';\n\n    try {\n      \n      const mergedOptions: ScreenShareOptions = {\n        ...defaultOptions,\n        ...options,\n      };\n\n      \n      const constraints: DisplayMediaStreamOptions = {\n        video: mergedOptions.video ?? true,\n        audio: mergedOptions.audio ?? false,\n      };\n\n      \n      if (mergedOptions.preferCurrentTab !== undefined) {\n        (constraints as any).preferCurrentTab = mergedOptions.preferCurrentTab;\n      }\n      if (mergedOptions.surfaceSwitching !== undefined) {\n        (constraints as any).surfaceSwitching = mergedOptions.surfaceSwitching;\n      }\n      if (mergedOptions.selfBrowserSurface !== undefined) {\n        (constraints as any).selfBrowserSurface = mergedOptions.selfBrowserSurface;\n      }\n      \n      if (mergedOptions.systemAudio !== undefined) {\n        (constraints as any).systemAudio = mergedOptions.systemAudio;\n      } else if (mergedOptions.audio) {\n        \n        (constraints as any).systemAudio = 'include';\n      }\n\n      const stream = await navigator.mediaDevices.getDisplayMedia(constraints);\n\n      screenStream.value = stream;\n      shareState.value = 'active';\n\n      \n      detectShareType(stream);\n\n      \n      const videoTrack = stream.getVideoTracks()[0];\n      if (videoTrack) {\n        videoTrack.addEventListener('ended', handleStreamEnded);\n      }\n\n      onShareStarted?.(stream);\n      return stream;\n    } catch (error) {\n      shareState.value = 'error';\n      const err = error as Error;\n      errors.value.push(err);\n      onError?.(err);\n      throw error;\n    }\n  };\n\n  \n  const stopScreenShare: ScreenShareStopFn = () => {\n    if (screenStream.value) {\n      \n      const videoTrack = screenStream.value.getVideoTracks()[0];\n      if (videoTrack) {\n        videoTrack.removeEventListener('ended', handleStreamEnded);\n      }\n\n      \n      screenStream.value.getTracks().forEach((track) => track.stop());\n      screenStream.value = null;\n      shareState.value = 'idle';\n      shareType.value = null;\n      onShareStopped?.();\n    }\n  };\n\n  \n  onBeforeUnmount(() => {\n    stopScreenShare();\n  });\n\n  \n  return {\n    \n    screenStream,\n    \n    shareState,\n    \n    shareType,\n    \n    errors,\n    \n    isSharing,\n    \n    startScreenShare,\n    \n    stopScreenShare,\n  };\n}\n"
      }
    ]
  }
}
{
  "control-button": {
    "dependsOn": [],
    "usedBy": [],
    "files": [
      {
        "name": "ControlButton.vue",
        "path": "registry/new-york/components/control-button/ControlButton.vue",
        "source": "<script setup lang=\"ts\">\nimport type { PrimitiveProps } from 'reka-ui';\nimport type { HTMLAttributes } from 'vue';\nimport type { ControlButtonVariants } from '.';\nimport { Primitive } from 'reka-ui';\nimport { cn } from '@/lib/utils';\nimport { buttonVariants } from '.';\n\nimport { ControlButtonLabel } from '~~/registry/new-york/components/control-button';\n\nexport interface ControlButtonProps extends PrimitiveProps {\n  variant?: ControlButtonVariants['variant'];\n  size?: ControlButtonVariants['size'];\n  shape?: ControlButtonVariants['shape'];\n  class?: HTMLAttributes['class'];\n}\n\nconst props = withDefaults(defineProps<ControlButtonProps>(), {\n  as: 'button',\n  shape: 'square',\n});\n</script>\n\n<template>\n  <div class=\"flex flex-col items-center justify-center\">\n    <Primitive\n      data-slot=\"button\"\n      :as=\"as\"\n      :as-child=\"asChild\"\n      :class=\"cn(buttonVariants({ variant, size, shape }), props.class)\"\n    >\n    </Primitive>\n    \n    <slot />\n  </div>\n</template>\n"
      },
      {
        "name": "ControlButtonLabel.vue",
        "path": "registry/new-york/components/control-button/ControlButtonLabel.vue",
        "source": "<script setup lang=\"ts\">\nimport type { HTMLAttributes } from 'vue';\nimport { cn } from '@/lib/utils';\n\nimport { Label } from '@/components/ui/label';\n\nexport interface ControlButtonLabelProps {\n  class?: HTMLAttributes['class'];\n}\n\nconst props = defineProps<ControlButtonLabelProps>();\n</script>\n\n<template>\n  <div class=\"flex flex-col items-center justify-center\">\n    <Label :class=\"cn(props.class)\">\n      <slot />\n    </Label>\n  </div>\n</template>\n"
      },
      {
        "name": "index.ts",
        "path": "registry/new-york/components/control-button/index.ts",
        "source": "\n\nimport type { VariantProps } from 'class-variance-authority';\nimport { cva } from 'class-variance-authority';\n\nexport { default as ControlButton } from './ControlButton.vue';\nexport { default as ControlButtonLabel } from './ControlButtonLabel.vue';\n\nexport const buttonVariants = cva(\n  \"aspect-square w-auto h-auto min-w-0 min-h-0 inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive\",\n  {\n    variants: {\n      variant: {\n        default: 'bg-primary text-primary-foreground shadow-xs hover:bg-primary/90',\n        destructive:\n          'bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60',\n        outline:\n          'border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50',\n        secondary: 'bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80',\n      },\n      size: {\n        default: 'size-9',\n        sm: 'size-8',\n        lg: 'size-10',\n      },\n      shape: {\n        square: 'rounded-md',\n        circle: 'rounded-full',\n      },\n    },\n    defaultVariants: {\n      variant: 'default',\n      size: 'default',\n      shape: 'square',\n    },\n  }\n);\n\nexport type ControlButtonVariants = VariantProps<typeof buttonVariants>;\nexport { type ControlButtonProps } from './ControlButton.vue';\nexport { type ControlButtonLabelProps } from './ControlButtonLabel.vue';\n"
      }
    ]
  },
  "media-devices-provider": {
    "dependsOn": [
      {
        "path": "composables/use-media-devices",
        "files": [
          "index.ts",
          "foo.ts",
          "useMediaDevices.ts"
        ]
      }
    ],
    "usedBy": [],
    "files": [
      {
        "name": "AudioDevice.vue",
        "path": "registry/new-york/components/media-devices-provider/AudioDevice.vue",
        "source": "<script setup lang=\"ts\">\n\n\nimport { ref, watch, onMounted, onBeforeUnmount, computed, inject, type Ref } from 'vue';\nimport {\n  MediaDevicesStartKey,\n  MediaDevicesStopKey,\n  MediaDevicesLoadingKey,\n  MediaDevicesPermissionsKey,\n  MediaDevicesActiveStreamsKey,\n  type MediaPermissions,\n} from '.';\nimport type { MediaDevicesStartFn, MediaDevicesStopFn } from '.';\n\nexport interface AudioDeviceProps {\n  \n  autoStart?: boolean;\n  \n  deviceId: string;\n\n  \n\n  \n  echoCancellation?: boolean;\n  \n  noiseSuppression?: boolean;\n  \n  autoGainControl?: boolean;\n  \n  sampleRate?: number | { min?: number; max?: number; ideal?: number };\n  \n  sampleSize?: number | { min?: number; max?: number; ideal?: number };\n\n  \n  constraints?: MediaStreamConstraints;\n}\n\nconst props = withDefaults(defineProps<AudioDeviceProps>(), {\n  autoStart: false,\n});\n\nconst emit = defineEmits<{\n  stream: [stream: MediaStream | null];\n  error: [error: Error];\n  started: [];\n  stopped: [];\n}>();\n\n\nconst providerStart = inject<MediaDevicesStartFn>(MediaDevicesStartKey);\nconst providerStop = inject<MediaDevicesStopFn>(MediaDevicesStopKey);\nconst providerIsLoading = inject<Ref<boolean>>(MediaDevicesLoadingKey, ref(false));\nconst providerPermissions = inject<Ref<MediaPermissions>>(\n  MediaDevicesPermissionsKey,\n  ref({ camera: 'unknown', microphone: 'unknown' })\n);\nconst providerActiveStreams = inject<Readonly<Ref<ReadonlyMap<string, MediaStream>>>>(\n  MediaDevicesActiveStreamsKey,\n  computed(() => new Map() as ReadonlyMap<string, MediaStream>)\n);\n\nconst stream = ref<MediaStream | null>(null);\nconst error = ref<Error | null>(null);\nconst isActive = ref(false);\nconst isLoading = ref(false);\nconst currentDeviceId = ref<string | undefined>(undefined);\n\n\nconst buildConstraints = (): MediaStreamConstraints => {\n  \n  if (props.constraints) {\n    return props.constraints;\n  }\n\n  const audioConstraints: MediaTrackConstraints = {\n    deviceId: { exact: props.deviceId },\n    echoCancellation: props.echoCancellation,\n    noiseSuppression: props.noiseSuppression,\n    autoGainControl: props.autoGainControl,\n    sampleRate: props.sampleRate\n      ? typeof props.sampleRate === 'number'\n        ? { ideal: props.sampleRate }\n        : props.sampleRate\n      : undefined,\n    sampleSize: props.sampleSize\n      ? typeof props.sampleSize === 'number'\n        ? { ideal: props.sampleSize }\n        : props.sampleSize\n      : undefined,\n  };\n\n  return {\n    video: false,\n    audio: audioConstraints,\n  };\n};\n\n\nconst start = async () => {\n  if (typeof navigator === 'undefined' || !navigator.mediaDevices) {\n    return;\n  }\n\n  if (isActive.value || isLoading.value) {\n    return;\n  }\n\n  try {\n    isLoading.value = true;\n    error.value = null;\n    const constraints = buildConstraints();\n\n    if (providerStart) {\n      stream.value = await providerStart(props.deviceId, constraints);\n    } else {\n      stream.value = await navigator.mediaDevices.getUserMedia(constraints);\n    }\n\n    currentDeviceId.value = props.deviceId;\n    isActive.value = true;\n    emit('stream', stream.value);\n    emit('started');\n  } catch (err) {\n    const errorObj = err as Error;\n    error.value = errorObj;\n    emit('error', errorObj);\n  } finally {\n    isLoading.value = false;\n  }\n};\n\n\nconst stop = () => {\n  if (!isActive.value) return;\n\n  const deviceIdToStop = currentDeviceId.value;\n\n  if (deviceIdToStop && providerStop) {\n    providerStop(deviceIdToStop);\n  } else if (stream.value) {\n    stream.value.getTracks().forEach((track) => track.stop());\n  }\n\n  stream.value = null;\n  isActive.value = false;\n  currentDeviceId.value = undefined;\n  emit('stream', null);\n  emit('stopped');\n};\n\n\nconst switchDevice = async () => {\n  const previousDeviceId = currentDeviceId.value;\n\n  \n  stream.value = null;\n  isActive.value = false;\n  currentDeviceId.value = undefined;\n\n  \n  emit('stream', null);\n\n  \n  await start();\n};\n\n\nwatch(\n  () => [\n    props.deviceId,\n    props.echoCancellation,\n    props.noiseSuppression,\n    props.autoGainControl,\n    props.sampleRate,\n    props.sampleSize,\n    props.constraints,\n  ],\n  async (newVals, oldVals) => {\n    const deviceIdChanged = newVals[0] !== oldVals?.[0];\n\n    if (deviceIdChanged) {\n      \n      if (isActive.value) {\n        \n        await switchDevice();\n      } else if (props.autoStart) {\n        \n        await start();\n      }\n    } else if (isActive.value) {\n      \n      stop();\n      await new Promise((resolve) => setTimeout(resolve, 50));\n      await start();\n    }\n  }\n);\n\nonMounted(() => {\n  if (props.autoStart) {\n    start();\n  }\n});\n\nonBeforeUnmount(() => {\n  stop();\n});\n\ndefineExpose({\n  start,\n  stop,\n  stream: computed(() => stream.value),\n  isActive: computed(() => isActive.value),\n  isLoading: computed(() => isLoading.value),\n  providerIsLoading: computed(() => providerIsLoading.value),\n  providerPermissions: computed(() => providerPermissions.value),\n  providerActiveStreams: computed(() => providerActiveStreams.value),\n  error: computed(() => error.value),\n});\n</script>\n\n<template>\n  <slot\n    :stream=\"stream\"\n    :is-active=\"isActive\"\n    :is-loading=\"isLoading\"\n    :provider-is-loading=\"providerIsLoading\"\n    :provider-permissions=\"providerPermissions\"\n    :provider-active-streams=\"providerActiveStreams\"\n    :error=\"error\"\n    :start=\"start\"\n    :stop=\"stop\"\n  />\n</template>\n\n<style scoped></style>\n"
      },
      {
        "name": "MediaDevicesProvider.vue",
        "path": "registry/new-york/components/media-devices-provider/MediaDevicesProvider.vue",
        "source": "<script setup lang=\"ts\">\n\n\nimport { provide, watch, onMounted, type Ref } from 'vue';\nimport { useMediaDevices } from '~~/registry/new-york/composables/use-media-devices/useMediaDevices';\nimport {\n  MediaDevicesKey,\n  MediaDevicesErrorsKey,\n  MediaDevicesLoadingKey,\n  MediaDevicesPermissionsKey,\n  MediaDevicesActiveStreamsKey,\n  MediaDevicesStartKey,\n  MediaDevicesStopKey,\n  MediaDevicesStopAllKey,\n  type MediaDevicesStartFn,\n  type MediaDevicesStopFn,\n  type MediaDevicesStopAllFn,\n  type MediaDeviceType,\n  type MediaPermissions,\n} from '.';\n\nexport interface MediaDevicesProviderProps {\n  \n  type?: MediaDeviceType;\n  \n  open?: boolean;\n}\n\nconst props = withDefaults(defineProps<MediaDevicesProviderProps>(), {\n  type: 'all',\n  open: false,\n});\n\nconst emit = defineEmits<{\n  streamStarted: [deviceId: string, stream: MediaStream];\n  streamStopped: [deviceId: string];\n  allStreamsStopped: [];\n  devicesUpdated: [devices: MediaDeviceInfo[]];\n  error: [error: Error];\n}>();\n\n\nconst {\n  devices,\n  cameras,\n  microphones,\n  speakers,\n  errors,\n  isLoading,\n  permissions,\n  activeStreams,\n  startStream,\n  stopStream,\n  stopAllStreams,\n  updateAvailableDevices,\n  ensurePermissions,\n  initialize,\n} = useMediaDevices({\n  type: props.type,\n  open: props.open,\n  onStreamStarted: (deviceId, stream) => emit('streamStarted', deviceId, stream),\n  onStreamStopped: (deviceId) => emit('streamStopped', deviceId),\n  onAllStreamsStopped: () => emit('allStreamsStopped'),\n  onDevicesUpdated: (devices) => emit('devicesUpdated', devices),\n  onError: (error) => emit('error', error),\n});\n\n\n\n\nprovide<Ref<MediaDeviceInfo[]>>(MediaDevicesKey, devices);\n\n\nprovide<Ref<Error[]>>(MediaDevicesErrorsKey, errors);\n\n\nprovide<Ref<boolean>>(MediaDevicesLoadingKey, isLoading);\n\n\nprovide<Ref<MediaPermissions>>(MediaDevicesPermissionsKey, permissions);\n\n\nprovide(MediaDevicesActiveStreamsKey, activeStreams);\n\n\nprovide<MediaDevicesStartFn>(MediaDevicesStartKey, startStream);\n\n\nprovide<MediaDevicesStopFn>(MediaDevicesStopKey, stopStream);\n\n\nprovide<MediaDevicesStopAllFn>(MediaDevicesStopAllKey, stopAllStreams);\n\n\nwatch(\n  () => [props.type, props.open] as const,\n  async ([newType, newOpen], oldValue) => {\n    const [oldType, oldOpen] = oldValue || [props.type, false];\n\n    \n    if (newOpen && !oldOpen) {\n      await ensurePermissions();\n      await updateAvailableDevices();\n    }\n    \n    else if (!newOpen && oldOpen) {\n      stopAllStreams();\n    }\n    \n    else if (newOpen && newType !== oldType) {\n      \n      \n      const shouldStopAll =\n        oldType === 'all' || \n        (oldType === 'camera' && newType === 'microphone') || \n        (oldType === 'microphone' && newType === 'camera'); \n\n      if (shouldStopAll) {\n        stopAllStreams();\n      }\n\n      await ensurePermissions();\n      await updateAvailableDevices();\n    }\n  }\n);\n\n\nonMounted(async () => {\n  await initialize();\n});\n</script>\n\n<template>\n  \n  <slot\n    :devices=\"devices\"\n    :errors=\"errors\"\n    :is-loading=\"isLoading\"\n    :permissions=\"permissions\"\n    :active-streams=\"activeStreams\"\n    :cameras=\"cameras\"\n    :microphones=\"microphones\"\n    :speakers=\"speakers\"\n    :start=\"startStream\"\n    :stop=\"stopStream\"\n    :stop-all=\"stopAllStreams\"\n    :cached-streams-count=\"activeStreams.size\"\n  />\n</template>\n\n<style scoped></style>\n"
      },
      {
        "name": "VideoDevice.vue",
        "path": "registry/new-york/components/media-devices-provider/VideoDevice.vue",
        "source": "<script setup lang=\"ts\">\n\n\nimport { ref, watch, onMounted, onBeforeUnmount, computed, inject, type Ref } from 'vue';\nimport {\n  MediaDevicesStartKey,\n  MediaDevicesStopKey,\n  MediaDevicesLoadingKey,\n  MediaDevicesPermissionsKey,\n  MediaDevicesActiveStreamsKey,\n  type MediaPermissions,\n} from '.';\nimport type { MediaDevicesStartFn, MediaDevicesStopFn } from '.';\n\nexport interface VideoDeviceProps {\n  \n  autoStart?: boolean;\n  \n  deviceId?: string;\n\n  \n\n  \n  width?: number | { min?: number; max?: number; ideal?: number };\n  \n  height?: number | { min?: number; max?: number; ideal?: number };\n  \n  frameRate?: number | { min?: number; max?: number; ideal?: number };\n  \n  facingMode?: 'user' | 'environment' | 'left' | 'right';\n  \n  aspectRatio?: number | { min?: number; max?: number; ideal?: number };\n\n  \n  constraints?: MediaStreamConstraints;\n}\n\nconst props = withDefaults(defineProps<VideoDeviceProps>(), {\n  autoStart: false,\n});\n\nconst emit = defineEmits<{\n  stream: [stream: MediaStream | null];\n  error: [error: Error];\n  started: [];\n  stopped: [];\n}>();\n\n\nconst providerStart = inject<MediaDevicesStartFn>(MediaDevicesStartKey);\nconst providerStop = inject<MediaDevicesStopFn>(MediaDevicesStopKey);\nconst providerIsLoading = inject<Ref<boolean>>(MediaDevicesLoadingKey, ref(false));\nconst providerPermissions = inject<Ref<MediaPermissions>>(\n  MediaDevicesPermissionsKey,\n  ref({ camera: 'unknown', microphone: 'unknown' })\n);\nconst providerActiveStreams = inject<Readonly<Ref<ReadonlyMap<string, MediaStream>>>>(\n  MediaDevicesActiveStreamsKey,\n  computed(() => new Map() as ReadonlyMap<string, MediaStream>)\n);\n\nconst stream = ref<MediaStream | null>(null);\nconst error = ref<Error | null>(null);\nconst isActive = ref(false);\nconst isLoading = ref(false);\nconst currentDeviceId = ref<string | undefined>(undefined);\n\n\nconst buildConstraints = (): MediaStreamConstraints => {\n  \n  if (props.constraints) {\n    return props.constraints;\n  }\n\n  \n  if (!props.deviceId && !props.facingMode) {\n    throw new Error('Either deviceId or facingMode must be provided');\n  }\n\n  const videoConstraints: MediaTrackConstraints = {\n    \n    \n    \n    ...(props.facingMode\n      ? { facingMode: { ideal: props.facingMode } }\n      : { deviceId: { exact: props.deviceId } }),\n    width: props.width\n      ? typeof props.width === 'number'\n        ? { ideal: props.width }\n        : props.width\n      : undefined,\n    height: props.height\n      ? typeof props.height === 'number'\n        ? { ideal: props.height }\n        : props.height\n      : undefined,\n    aspectRatio: props.aspectRatio\n      ? typeof props.aspectRatio === 'number'\n        ? { ideal: props.aspectRatio }\n        : props.aspectRatio\n      : undefined,\n    frameRate: props.frameRate\n      ? typeof props.frameRate === 'number'\n        ? { ideal: props.frameRate }\n        : props.frameRate\n      : undefined,\n  };\n\n  return {\n    video: videoConstraints,\n    audio: false,\n  };\n};\n\n\nconst start = async () => {\n  if (typeof navigator === 'undefined' || !navigator.mediaDevices) {\n    return;\n  }\n\n  if (isActive.value || isLoading.value) {\n    return;\n  }\n\n  try {\n    isLoading.value = true;\n    error.value = null;\n    const constraints = buildConstraints();\n\n    if (providerStart && props.deviceId && !props.facingMode) {\n      \n      \n      stream.value = await providerStart(props.deviceId, constraints);\n    } else {\n      stream.value = await navigator.mediaDevices.getUserMedia(constraints);\n    }\n\n    currentDeviceId.value = props.deviceId;\n    isActive.value = true;\n    emit('stream', stream.value);\n    emit('started');\n  } catch (err) {\n    const errorObj = err as Error;\n    error.value = errorObj;\n    emit('error', errorObj);\n  } finally {\n    isLoading.value = false;\n  }\n};\n\n\nconst stop = () => {\n  if (!isActive.value) return;\n\n  const deviceIdToStop = currentDeviceId.value;\n\n  if (deviceIdToStop && providerStop) {\n    providerStop(deviceIdToStop);\n  } else if (stream.value) {\n    stream.value.getTracks().forEach((track) => track.stop());\n  }\n\n  stream.value = null;\n  isActive.value = false;\n  currentDeviceId.value = undefined;\n  emit('stream', null);\n  emit('stopped');\n};\n\n\nconst switchDevice = async () => {\n  const previousDeviceId = currentDeviceId.value;\n\n  \n  stream.value = null;\n  isActive.value = false;\n  currentDeviceId.value = undefined;\n\n  \n  emit('stream', null);\n\n  \n  await start();\n};\n\n\nwatch(\n  () => [\n    props.deviceId,\n    props.width,\n    props.height,\n    props.frameRate,\n    props.facingMode,\n    props.aspectRatio,\n    props.constraints,\n  ],\n  async (newVals, oldVals) => {\n    const deviceIdChanged = newVals[0] !== oldVals?.[0];\n\n    if (deviceIdChanged) {\n      \n      if (isActive.value) {\n        \n        await switchDevice();\n      } else if (props.autoStart) {\n        \n        await start();\n      }\n    } else if (isActive.value) {\n      \n      stop();\n      await new Promise((resolve) => setTimeout(resolve, 50));\n      await start();\n    }\n  }\n);\n\nonMounted(() => {\n  if (props.autoStart) {\n    start();\n  }\n});\n\nonBeforeUnmount(() => {\n  stop();\n});\n\ndefineExpose({\n  start,\n  stop,\n  stream: computed(() => stream.value),\n  isActive: computed(() => isActive.value),\n  isLoading: computed(() => isLoading.value),\n  providerIsLoading: computed(() => providerIsLoading.value),\n  providerPermissions: computed(() => providerPermissions.value),\n  providerActiveStreams: computed(() => providerActiveStreams.value),\n  error: computed(() => error.value),\n});\n</script>\n\n<template>\n  <slot\n    :stream=\"stream\"\n    :is-active=\"isActive\"\n    :is-loading=\"isLoading\"\n    :provider-is-loading=\"providerIsLoading\"\n    :provider-permissions=\"providerPermissions\"\n    :provider-active-streams=\"providerActiveStreams\"\n    :error=\"error\"\n    :start=\"start\"\n    :stop=\"stop\"\n  />\n</template>\n\n<style scoped></style>\n"
      },
      {
        "name": "index.ts",
        "path": "registry/new-york/components/media-devices-provider/index.ts",
        "source": "\nimport type { InjectionKey, Ref } from 'vue';\n\nexport { default as MediaDevicesProvider } from './MediaDevicesProvider.vue';\nexport { default as VideoDevice } from './VideoDevice.vue';\nexport { default as AudioDevice } from './AudioDevice.vue';\n\nexport { type MediaDevicesProviderProps } from './MediaDevicesProvider.vue';\nexport { type VideoDeviceProps } from './VideoDevice.vue';\nexport { type AudioDeviceProps } from './AudioDevice.vue';\n\n\nexport type MediaDeviceType = 'camera' | 'microphone' | 'all';\n\n\nexport type MediaDeviceKind = 'videoinput' | 'audioinput' | 'audiooutput';\n\n\nexport type MediaPermissionState = 'granted' | 'denied' | 'prompt' | 'unknown';\n\n\nexport interface MediaPermissions {\n  camera: MediaPermissionState;\n  microphone: MediaPermissionState;\n}\n\n\nexport interface FilteredDevices {\n  cameras: MediaDeviceInfo[];\n  microphones: MediaDeviceInfo[];\n  speakers: MediaDeviceInfo[];\n}\n\n\nexport type CameraConstraints = MediaStreamConstraints & {\n  video: MediaTrackConstraints | boolean;\n  audio?: MediaTrackConstraints | boolean;\n};\n\n\nexport type MicrophoneConstraints = MediaStreamConstraints & {\n  audio: MediaTrackConstraints | boolean;\n  video?: MediaTrackConstraints | boolean;\n};\n\n\nexport type DeviceConstraints = CameraConstraints | MicrophoneConstraints | MediaStreamConstraints;\n\n\nexport type MediaDeviceErrorName =\n  | 'NotFoundError'\n  | 'NotAllowedError'\n  | 'NotReadableError'\n  | 'OverconstrainedError'\n  | 'TypeError'\n  | 'AbortError'\n  | 'SecurityError';\n\n\nexport interface MediaDeviceError extends Error {\n  name: MediaDeviceErrorName;\n  constraint?: string;\n}\n\n\nexport interface MediaDevicesProviderSlotProps {\n  \n  devices: MediaDeviceInfo[];\n  \n  cameras: MediaDeviceInfo[];\n  \n  microphones: MediaDeviceInfo[];\n  \n  speakers: MediaDeviceInfo[];\n  \n  errors: Error[];\n  \n  isLoading: boolean;\n  \n  permissions: MediaPermissions;\n  \n  activeStreams: ReadonlyMap<string, MediaStream>;\n  \n  start: MediaDevicesStartFn;\n  \n  stop: MediaDevicesStopFn;\n  \n  stopAll: MediaDevicesStopAllFn;\n  \n  cachedStreamsCount: number;\n}\n\n\nexport type MediaDevicesStartFn = (\n  deviceId: string,\n  constraints: MediaStreamConstraints\n) => Promise<MediaStream>;\n\n\nexport type MediaDevicesStopFn = (deviceId: string) => void;\n\n\nexport type MediaDevicesStopAllFn = () => void;\n\n\nexport type MediaDevicesIsActiveStreamFn = (deviceId: string) => boolean;\n\nexport const MediaDevicesKey: InjectionKey<Ref<MediaDeviceInfo[]>> = Symbol('MediaDevices');\nexport const MediaDevicesErrorsKey: InjectionKey<Ref<Error[]>> = Symbol('MediaDevicesErrors');\nexport const MediaDevicesLoadingKey: InjectionKey<Ref<boolean>> = Symbol('MediaDevicesLoading');\nexport const MediaDevicesPermissionsKey: InjectionKey<Ref<MediaPermissions>> =\n  Symbol('MediaDevicesPermissions');\nexport const MediaDevicesActiveStreamsKey: InjectionKey<\n  Readonly<Ref<ReadonlyMap<string, MediaStream>>>\n> = Symbol('MediaDevicesActiveStreams');\nexport const MediaDevicesStartKey: InjectionKey<MediaDevicesStartFn> = Symbol('MediaDevicesStart');\nexport const MediaDevicesStopKey: InjectionKey<MediaDevicesStopFn> = Symbol('MediaDevicesStop');\nexport const MediaDevicesStopAllKey: InjectionKey<MediaDevicesStopAllFn> =\n  Symbol('MediaDevicesStopAll');\n\n\nexport { VideoPresets, AudioPresets, MediaPresets } from './presets';\n"
      },
      {
        "name": "presets.ts",
        "path": "registry/new-york/components/media-devices-provider/presets.ts",
        "source": "\n\nexport const VideoPresets = {\n  \n  sd: {\n    width: 640,\n    height: 480,\n    frameRate: 30,\n  },\n\n  \n  hd: {\n    width: 1280,\n    height: 720,\n    frameRate: 30,\n  },\n\n  \n  fullHd: {\n    width: 1920,\n    height: 1080,\n    frameRate: 30,\n  },\n\n  \n  uhd4k: {\n    width: 3840,\n    height: 2160,\n    frameRate: 30,\n  },\n\n  \n  adaptiveHd: {\n    width: { min: 640, ideal: 1920, max: 3840 },\n    height: { min: 480, ideal: 1080, max: 2160 },\n    frameRate: { min: 24, ideal: 30, max: 60 },\n  },\n\n  \n  mobileFront: {\n    width: { ideal: 1280 },\n    height: { ideal: 720 },\n    frameRate: { ideal: 30 },\n    facingMode: 'user' as const,\n  },\n\n  \n  mobileBack: {\n    width: { ideal: 1920 },\n    height: { ideal: 1080 },\n    frameRate: { ideal: 30 },\n    facingMode: 'environment' as const,\n  },\n\n  \n  conference: {\n    width: 1280,\n    height: 720,\n    frameRate: 30,\n    aspectRatio: 1.777, \n  },\n\n  \n  screenRecording: {\n    width: { ideal: 1920 },\n    height: { ideal: 1080 },\n    frameRate: { ideal: 60 },\n    aspectRatio: 1.777,\n  },\n} as const;\n\n\nexport const AudioPresets = {\n  \n  default: {\n    echoCancellation: true,\n    noiseSuppression: true,\n    autoGainControl: true,\n  },\n\n  \n  highQuality: {\n    echoCancellation: false,\n    noiseSuppression: false,\n    autoGainControl: false,\n    sampleRate: 48000,\n  },\n\n  \n  voice: {\n    echoCancellation: true,\n    noiseSuppression: true,\n    autoGainControl: true,\n    sampleRate: 48000,\n  },\n\n  \n  conference: {\n    echoCancellation: true,\n    noiseSuppression: true,\n    autoGainControl: true,\n    sampleRate: { ideal: 48000 },\n  },\n\n  \n  raw: {\n    echoCancellation: false,\n    noiseSuppression: false,\n    autoGainControl: false,\n  },\n} as const;\n\n\nexport const MediaPresets = {\n  \n  videoConference: {\n    ...VideoPresets.conference,\n    ...AudioPresets.conference,\n  },\n\n  \n  screenRecording: {\n    ...VideoPresets.screenRecording,\n    ...AudioPresets.voice,\n  },\n\n  \n  podcast: {\n    ...AudioPresets.highQuality,\n  },\n\n  \n  mobileSelfie: {\n    ...VideoPresets.mobileFront,\n    ...AudioPresets.default,\n  },\n\n  \n  mobileVideo: {\n    ...VideoPresets.mobileBack,\n    ...AudioPresets.default,\n  },\n} as const;\n"
      }
    ]
  },
  "screen-share-provider": {
    "dependsOn": [
      {
        "path": "composables/use-screen-share",
        "files": [
          "useScreenShare.ts"
        ]
      }
    ],
    "usedBy": [],
    "files": [
      {
        "name": "ScreenShareProvider.vue",
        "path": "registry/new-york/components/screen-share-provider/ScreenShareProvider.vue",
        "source": "<script setup lang=\"ts\">\n\n\nimport { provide, watch, nextTick, type Ref } from 'vue';\nimport { useScreenShare } from '~~/registry/new-york/composables/use-screen-share/useScreenShare';\nimport {\n  ScreenShareStreamKey,\n  ScreenShareStateKey,\n  ScreenShareTypeKey,\n  ScreenShareErrorsKey,\n  ScreenShareStartKey,\n  ScreenShareStopKey,\n  type ScreenShareOptions,\n  type ScreenShareState,\n  type ScreenShareType,\n  type ScreenShareStartFn,\n  type ScreenShareStopFn,\n} from '.';\n\nexport interface ScreenShareProviderProps {\n  \n  autoStart?: boolean;\n  \n  defaultOptions?: ScreenShareOptions;\n}\n\nconst props = withDefaults(defineProps<ScreenShareProviderProps>(), {\n  autoStart: false,\n});\n\nconst emit = defineEmits<{\n  shareStarted: [stream: MediaStream];\n  shareStopped: [];\n  error: [error: Error];\n}>();\n\n\nconst {\n  screenStream,\n  shareState,\n  shareType,\n  errors,\n  isSharing,\n  startScreenShare,\n  stopScreenShare,\n} = useScreenShare({\n  defaultOptions: props.defaultOptions,\n  onShareStarted: (stream) => emit('shareStarted', stream),\n  onShareStopped: () => emit('shareStopped'),\n  onError: (error) => emit('error', error),\n});\n\n\nprovide<Ref<MediaStream | null>>(ScreenShareStreamKey, screenStream);\nprovide<Ref<ScreenShareState>>(ScreenShareStateKey, shareState);\nprovide<Ref<ScreenShareType | null>>(ScreenShareTypeKey, shareType);\nprovide<Ref<Error[]>>(ScreenShareErrorsKey, errors);\nprovide<ScreenShareStartFn>(ScreenShareStartKey, startScreenShare);\nprovide<ScreenShareStopFn>(ScreenShareStopKey, stopScreenShare);\n\n\nwatch(\n  () => props.autoStart,\n  async (autoStart) => {\n    if (autoStart) {\n      await nextTick();\n      try {\n        await startScreenShare(props.defaultOptions);\n      } catch (error) {\n        \n      }\n    }\n  },\n  { immediate: true }\n);\n</script>\n\n<template>\n  \n  <slot\n    :screen-stream=\"screenStream\"\n    :share-state=\"shareState\"\n    :share-type=\"shareType\"\n    :errors=\"errors\"\n    :is-sharing=\"isSharing\"\n    :start-share=\"startScreenShare\"\n    :stop-share=\"stopScreenShare\"\n  />\n</template>\n\n<style scoped></style>\n"
      },
      {
        "name": "ScreenShareViewer.vue",
        "path": "registry/new-york/components/screen-share-provider/ScreenShareViewer.vue",
        "source": "<script setup lang=\"ts\">\n\n\nimport { inject, ref, watch, onBeforeUnmount, computed } from 'vue';\nimport {\n  ScreenShareStreamKey,\n  ScreenShareStateKey,\n  ScreenShareStartKey,\n  ScreenShareStopKey,\n  type ScreenShareOptions,\n} from '.';\n\nexport interface ScreenShareViewerProps {\n  \n  options?: ScreenShareOptions;\n  \n  autoPlay?: boolean;\n  \n  muted?: boolean;\n  \n  controls?: boolean;\n  \n  class?: string;\n  \n  autoStart?: boolean;\n}\n\nconst props = withDefaults(defineProps<ScreenShareViewerProps>(), {\n  autoPlay: true,\n  muted: true,\n  controls: false,\n  autoStart: false,\n});\n\nconst emit = defineEmits<{\n  playing: [];\n  paused: [];\n  error: [error: Event];\n}>();\n\n\nconst screenStream = inject(ScreenShareStreamKey);\nconst shareState = inject(ScreenShareStateKey);\nconst startShare = inject(ScreenShareStartKey);\nconst stopShare = inject(ScreenShareStopKey);\n\n\nconst videoRef = ref<HTMLVideoElement | null>(null);\n\n\nconst isPlaying = ref(false);\n\n\nconst isSharing = computed(() => shareState?.value === 'active');\n\n\nwatch(\n  [screenStream, videoRef],\n  () => {\n    if (videoRef.value && screenStream?.value) {\n      videoRef.value.srcObject = screenStream.value;\n\n      \n      if (props.autoPlay) {\n        videoRef.value.play().catch((error) => {\n          console.warn('Auto-play failed:', error);\n        });\n      }\n    } else if (videoRef.value) {\n      videoRef.value.srcObject = null;\n    }\n  },\n  { immediate: true }\n);\n\n\nwatch(\n  [() => props.autoStart, isSharing],\n  async ([autoStart, sharing]) => {\n    if (autoStart && !sharing && startShare) {\n      try {\n        await startShare(props.options);\n      } catch (error) {\n        \n      }\n    }\n  },\n  { immediate: true }\n);\n\n\nconst handlePlay = () => {\n  isPlaying.value = true;\n  emit('playing');\n};\n\n\nconst handlePause = () => {\n  isPlaying.value = false;\n  emit('paused');\n};\n\n\nconst handleError = (event: Event) => {\n  emit('error', event);\n};\n\n\nonBeforeUnmount(() => {\n  if (videoRef.value) {\n    videoRef.value.srcObject = null;\n  }\n});\n</script>\n\n<template>\n  <video\n    ref=\"videoRef\"\n    :class=\"class\"\n    :autoplay=\"autoPlay\"\n    :muted=\"muted\"\n    :controls=\"controls\"\n    playsinline\n    @play=\"handlePlay\"\n    @pause=\"handlePause\"\n    @error=\"handleError\"\n  >\n    Your browser does not support the video element.\n  </video>\n</template>\n\n<style scoped>\nvideo {\n  max-width: 100%;\n  height: auto;\n}\n</style>\n"
      },
      {
        "name": "index.ts",
        "path": "registry/new-york/components/screen-share-provider/index.ts",
        "source": "\nimport type { InjectionKey, Ref } from 'vue';\nimport type {\n  ScreenShareType,\n  ScreenShareState,\n  ScreenShareStartFn,\n  ScreenShareStopFn,\n} from '~~/registry/new-york/composables/use-screen-share/useScreenShare';\n\nexport { default as ScreenShareProvider } from './ScreenShareProvider.vue';\nexport { default as ScreenShareViewer } from './ScreenShareViewer.vue';\n\nexport { type ScreenShareProviderProps } from './ScreenShareProvider.vue';\nexport { type ScreenShareViewerProps } from './ScreenShareViewer.vue';\n\n\nexport type {\n  ScreenShareType,\n  ScreenShareState,\n  ScreenShareOptions,\n  ScreenShareStartFn,\n  ScreenShareStopFn,\n} from '~~/registry/new-york/composables/use-screen-share/useScreenShare';\n\n\nexport interface ScreenShareProviderSlotProps {\n  \n  screenStream: MediaStream | null;\n  \n  shareState: ScreenShareState;\n  \n  shareType: ScreenShareType | null;\n  \n  errors: Error[];\n  \n  isSharing: boolean;\n  \n  startShare: ScreenShareStartFn;\n  \n  stopShare: ScreenShareStopFn;\n}\n\n\nexport const ScreenShareStreamKey: InjectionKey<Ref<MediaStream | null>> =\n  Symbol('ScreenShareStream');\n\nexport const ScreenShareStateKey: InjectionKey<Ref<ScreenShareState>> = Symbol('ScreenShareState');\n\nexport const ScreenShareTypeKey: InjectionKey<Ref<ScreenShareType | null>> =\n  Symbol('ScreenShareType');\n\nexport const ScreenShareErrorsKey: InjectionKey<Ref<Error[]>> = Symbol('ScreenShareErrors');\n\nexport const ScreenShareStartKey: InjectionKey<ScreenShareStartFn> = Symbol('ScreenShareStart');\n\nexport const ScreenShareStopKey: InjectionKey<ScreenShareStopFn> = Symbol('ScreenShareStop');\n"
      }
    ]
  },
  "simple-input": {
    "dependsOn": [],
    "usedBy": [],
    "files": [
      {
        "name": "SimpleInput.vue",
        "path": "registry/new-york/components/simple-input/SimpleInput.vue",
        "source": "<script lang=\"ts\">\n\n\nconst symKey = Symbol('symKey');\n\nexport default {\n  name: 'SimpleInput',\n  \n  props: {\n    \n    label: {\n      type: String,\n      required: false,\n      default: '',\n    },\n    \n    placeholder: {\n      type: String,\n      required: false,\n      default: '',\n    },\n    \n    modelValue: {\n      type: String,\n      required: false,\n      default: '',\n    },\n  },\n  emits: [\n    \n    'update:modelValue',\n  ],\n  inject: {\n    \n    injected: 'someKey',\n    \n    injectedSym: symKey,\n    \n    injectedSpread: 'spread',\n  },\n  provide() {\n    return {\n      \n      someOtherKey: 'providedValue',\n      \n      symKey: 'valSym',\n      \n      computedKey: true,\n    };\n  },\n  methods: {\n    onInput(event: Event) {\n      this.$emit('update:modelValue', (event.target as HTMLInputElement).value);\n    },\n  },\n  \n  expose: [\n    \n    'exposed',\n    \n    'other',\n    \n    'myFunc',\n  ],\n};\n</script>\n\n<template>\n  <div class=\"flex flex-col\">\n    <label v-if=\"label\">{{ label }}</label>\n    <input :placeholder=\"placeholder\" :value=\"modelValue\" @input=\"onInput\" type=\"text\" />\n  </div>\n</template>\n\n<style scoped>\n:root {\n  --input-border-color: #ccc;\n  --input-border-radius: 4px;\n  --input-padding: 0.5em 1em;\n  --input-font-size: 1em;\n}\n\ninput {\n  border: 1px solid #ccc;\n  border-radius: 4px;\n  padding: 0.5em 1em;\n  font-size: 1em;\n}\nlabel {\n  display: block;\n  margin-bottom: 0.25em;\n  font-weight: bold;\n}\n</style>\n"
      },
      {
        "name": "SimpleInputSetup.vue",
        "path": "registry/new-york/components/simple-input/SimpleInputSetup.vue",
        "source": "<script setup lang=\"ts\">\n\nimport { ref, inject, provide, defineExpose } from 'vue';\n\nconst props = defineProps({\n  \n  label: {\n    type: String,\n    required: false,\n    default: '',\n  },\n  \n  placeholder: {\n    type: String,\n    required: false,\n    default: '',\n  },\n  \n  modelValue: {\n    type: String,\n    required: false,\n    default: '',\n  },\n});\n\nconst emit = defineEmits<{\n  \n  (e: 'update:modelValue', value: string): void;\n}>();\n\nconst symKey = Symbol('symKey');\n\n\nconst injected = inject('someKey');\nconst injectedSym = inject(symKey);\nconst injectedSpread = inject('spread');\n\n\nprovide('someOtherKey', 'providedValue');\nprovide(symKey, 'valSym');\nprovide('computedKey', true);\n\n\nconst bar = ref('bar');\n\n\nfunction onInput(event: Event) {\n  emit('update:modelValue', (event.target as HTMLInputElement).value);\n}\n\n\nconst exposed = ref('exposed');\nconst other = ref('other');\nfunction myFunc() {\n  console.log('myFunc called');\n  return 'foo';\n}\ndefineExpose({ exposed, other, myFunc });\n</script>\n\n<template>\n  <label v-if=\"props.label\">{{ props.label }}</label>\n  <input :placeholder=\"props.placeholder\" :value=\"props.modelValue\" @input=\"onInput\" type=\"text\" />\n</template>\n\n<style scoped>\n:root {\n  --input-border-color: #ccc;\n  --input-border-radius: 4px;\n  --input-padding: 0.5em 1em;\n  --input-font-size: 1em;\n}\n\ninput {\n  border: 1px solid #ccc;\n  border-radius: 4px;\n  padding: 0.5em 1em;\n  font-size: 1em;\n}\nlabel {\n  display: block;\n  margin-bottom: 0.25em;\n  font-weight: bold;\n}\n</style>\n"
      },
      {
        "name": "index.ts",
        "path": "registry/new-york/components/simple-input/index.ts",
        "source": "\n\nexport { default as SimpleInput } from './SimpleInput.vue';\nexport { default as SimpleInputSetup } from './SimpleInputSetup.vue';\n"
      }
    ]
  },
  "use-media-devices": {
    "dependsOn": [
      {
        "path": "composables/use-media-devices",
        "files": [
          "index.ts",
          "foo.ts",
          "useMediaDevices.ts"
        ]
      }
    ],
    "usedBy": [
      "media-devices-provider",
      "use-media-devices"
    ],
    "files": [
      {
        "name": "index.ts",
        "path": "registry/new-york/composables/use-media-devices/bar/index.ts",
        "source": "export const bar = 'foo';\n"
      },
      {
        "name": "foo.ts",
        "path": "registry/new-york/composables/use-media-devices/foo.ts",
        "source": "import { bar } from './bar';\n\nexport const foo = 'bar';\n"
      },
      {
        "name": "useMediaDevices.ts",
        "path": "registry/new-york/composables/use-media-devices/useMediaDevices.ts",
        "source": "\n\nimport { ref, computed, onBeforeUnmount } from 'vue';\nimport { useEventListener } from '@vueuse/core';\n\n\nimport { foo } from './foo';\nimport { bar } from './bar';\n\n\nexport type MediaDeviceType = 'camera' | 'microphone' | 'all';\n\n\nexport type MediaDeviceKind = 'videoinput' | 'audioinput' | 'audiooutput';\n\n\nexport type MediaPermissionState = 'granted' | 'denied' | 'prompt' | 'unknown';\n\n\nexport interface MediaPermissions {\n  camera: MediaPermissionState;\n  microphone: MediaPermissionState;\n}\n\n\nexport type MediaDevicesStartFn = (\n  deviceId: string,\n  constraints: MediaStreamConstraints\n) => Promise<MediaStream>;\n\n\nexport type MediaDevicesStopFn = (deviceId: string) => void;\n\n\nexport type MediaDevicesStopAllFn = () => void;\n\n\nexport interface UseMediaDevicesOptions {\n  \n  type?: MediaDeviceType;\n  \n  open?: boolean;\n  \n  onStreamStarted?: (deviceId: string, stream: MediaStream) => void;\n  \n  onStreamStopped?: (deviceId: string) => void;\n  \n  onAllStreamsStopped?: () => void;\n  \n  onDevicesUpdated?: (devices: MediaDeviceInfo[]) => void;\n  \n  onError?: (error: Error) => void;\n}\n\nexport function useMediaDevices(options: UseMediaDevicesOptions = {}) {\n  const {\n    type = 'all',\n    open = false,\n    onStreamStarted,\n    onStreamStopped,\n    onAllStreamsStopped,\n    onDevicesUpdated,\n    onError,\n  } = options;\n\n  \n  const devices = ref<MediaDeviceInfo[]>([]);\n\n  \n  const errors = ref<Error[]>([]);\n\n  \n  const isLoading = ref<boolean>(false);\n\n  \n  const permissions = ref<MediaPermissions>({\n    camera: 'unknown',\n    microphone: 'unknown',\n  });\n\n  \n  const activeStreams = ref<Map<string, MediaStream>>(new Map());\n\n  \n  const filterDevicesByKind = (kind: MediaDeviceKind): MediaDeviceInfo[] => {\n    return devices.value.filter((d) => d.kind === kind);\n  };\n\n  \n  const cameras = computed(() => filterDevicesByKind('videoinput'));\n  const microphones = computed(() => filterDevicesByKind('audioinput'));\n  const speakers = computed(() => filterDevicesByKind('audiooutput'));\n\n  \n  const roActiveStreams = computed(() => activeStreams.value as ReadonlyMap<string, MediaStream>);\n\n  \n  const checkPermission = async (name: 'camera' | 'microphone'): Promise<MediaPermissionState> => {\n    if (typeof navigator === 'undefined' || !navigator.permissions) {\n      return 'unknown';\n    }\n\n    try {\n      const permissionName = name === 'camera' ? 'camera' : 'microphone';\n      const result = await navigator.permissions.query({ name: permissionName as PermissionName });\n      return result.state as MediaPermissionState;\n    } catch (error) {\n      \n      return 'unknown';\n    }\n  };\n\n  \n  const updatePermissions = async () => {\n    permissions.value.camera = await checkPermission('camera');\n    permissions.value.microphone = await checkPermission('microphone');\n  };\n\n  \n  const startStream: MediaDevicesStartFn = async (\n    deviceId: string,\n    constraints: MediaStreamConstraints\n  ): Promise<MediaStream> => {\n    \n    const existingStream = activeStreams.value.get(deviceId);\n    if (existingStream?.active) {\n      return existingStream;\n    }\n\n    \n    if (existingStream) {\n      activeStreams.value.delete(deviceId);\n    }\n\n    try {\n      \n      if (typeof navigator === 'undefined' || !navigator.mediaDevices) {\n        throw new Error('navigator.mediaDevices not available (SSR or unsupported browser)');\n      }\n\n      const stream = await navigator.mediaDevices.getUserMedia(constraints);\n\n      activeStreams.value.set(deviceId, stream);\n      onStreamStarted?.(deviceId, stream);\n      return stream;\n    } catch (error) {\n      const err = error as Error;\n      errors.value.push(err);\n      onError?.(err);\n      throw error;\n    }\n  };\n\n  \n  const stopStream: MediaDevicesStopFn = (deviceId: string) => {\n    const stream = activeStreams.value.get(deviceId);\n    if (stream) {\n      stream.getTracks().forEach((track) => track.stop());\n      activeStreams.value.delete(deviceId);\n      onStreamStopped?.(deviceId);\n    }\n  };\n\n  \n  const stopAllStreams: MediaDevicesStopAllFn = () => {\n    activeStreams.value.forEach((stream, _deviceId) => {\n      stream.getTracks().forEach((track) => track.stop());\n    });\n    activeStreams.value.clear();\n    onAllStreamsStopped?.();\n  };\n\n  \n  const updateAvailableDevices = async () => {\n    if (\n      typeof navigator === 'undefined' ||\n      !navigator.mediaDevices ||\n      !navigator.mediaDevices.enumerateDevices\n    ) {\n      devices.value = [];\n      return;\n    }\n\n    isLoading.value = true;\n    try {\n      devices.value = await navigator.mediaDevices.enumerateDevices();\n      onDevicesUpdated?.(devices.value);\n    } catch (error) {\n      const err = error as Error;\n      errors.value.push(err);\n      onError?.(err);\n    } finally {\n      isLoading.value = false;\n    }\n  };\n\n  \n  const requestMediaIfNeeded = async () => {\n    \n    if (typeof navigator === 'undefined' || !navigator.mediaDevices) {\n      return;\n    }\n\n    const needsVideo = type === 'camera' || type === 'all';\n    const needsAudio = type === 'microphone' || type === 'all';\n\n    try {\n      \n      \n      \n      const stream = await navigator.mediaDevices.getUserMedia({\n        video: needsVideo,\n        audio: needsAudio,\n      });\n      \n      \n      stream.getTracks().forEach((track) => track.stop());\n\n      \n      await updatePermissions();\n    } catch (error) {\n      const err = error as Error;\n      errors.value.push(err);\n      onError?.(err);\n\n      \n      await updatePermissions();\n    }\n  };\n\n  \n  const ensurePermissions = async () => {\n    if (open) {\n      await requestMediaIfNeeded();\n    }\n  };\n\n  \n  const initialize = async () => {\n    \n    await updatePermissions();\n\n    if (open) {\n      await ensurePermissions();\n      \n      await new Promise((resolve) => setTimeout(resolve, 100));\n      await updateAvailableDevices();\n    }\n  };\n\n  \n  if (typeof navigator !== 'undefined' && navigator.mediaDevices) {\n    useEventListener(navigator.mediaDevices, 'devicechange', updateAvailableDevices);\n  }\n\n  \n  onBeforeUnmount(() => {\n    stopAllStreams();\n  });\n\n  \n  return {\n    \n    devices,\n    \n    cameras,\n    \n    microphones,\n    \n    speakers,\n    \n    errors,\n    \n    isLoading,\n    \n    permissions,\n    \n    activeStreams: roActiveStreams,\n    \n    startStream,\n    \n    stopStream,\n    \n    stopAllStreams,\n    \n    updateAvailableDevices,\n    \n    ensurePermissions,\n    \n    initialize,\n  };\n}\n"
      }
    ]
  },
  "use-screen-share": {
    "dependsOn": [],
    "usedBy": [
      "screen-share-provider"
    ],
    "files": [
      {
        "name": "useScreenShare.ts",
        "path": "registry/new-york/composables/use-screen-share/useScreenShare.ts",
        "source": "\n\nimport { ref, computed, onBeforeUnmount } from 'vue';\n\n\nexport type ScreenShareType = 'monitor' | 'window' | 'browser';\n\n\nexport type ScreenShareState = 'idle' | 'requesting' | 'active' | 'error';\n\n\nexport interface ScreenShareOptions {\n  \n  video?: boolean | MediaTrackConstraints;\n  \n  audio?: boolean | MediaTrackConstraints;\n  \n  preferCurrentTab?: boolean;\n  \n  surfaceSwitching?: 'include' | 'exclude';\n  \n  selfBrowserSurface?: 'include' | 'exclude';\n  \n  systemAudio?: 'include' | 'exclude';\n}\n\n\nexport type ScreenShareStartFn = (options?: ScreenShareOptions) => Promise<MediaStream>;\n\n\nexport type ScreenShareStopFn = () => void;\n\nexport interface UseScreenShareOptions {\n  \n  defaultOptions?: ScreenShareOptions;\n  \n  onShareStarted?: (stream: MediaStream) => void;\n  \n  onShareStopped?: () => void;\n  \n  onError?: (error: Error) => void;\n}\n\nexport function useScreenShare(options: UseScreenShareOptions = {}) {\n  const { defaultOptions, onShareStarted, onShareStopped, onError } = options;\n\n  \n  const screenStream = ref<MediaStream | null>(null);\n\n  \n  const shareState = ref<ScreenShareState>('idle');\n\n  \n  const shareType = ref<ScreenShareType | null>(null);\n\n  \n  const errors = ref<Error[]>([]);\n\n  \n  const isSharing = computed(() => shareState.value === 'active');\n\n  \n  const detectShareType = (stream: MediaStream) => {\n    try {\n      const videoTrack = stream.getVideoTracks()[0];\n      if (!videoTrack) return;\n\n      const settings = videoTrack.getSettings();\n      \n      if ('displaySurface' in settings) {\n        shareType.value = settings.displaySurface as ScreenShareType;\n      }\n    } catch (error) {\n      \n      console.warn('Could not detect share type:', error);\n    }\n  };\n\n  \n  const handleStreamEnded = () => {\n    screenStream.value = null;\n    shareState.value = 'idle';\n    shareType.value = null;\n    onShareStopped?.();\n  };\n\n  \n  const startScreenShare: ScreenShareStartFn = async (options = {}) => {\n    \n    if (screenStream.value?.active) {\n      return screenStream.value;\n    }\n\n    \n    if (typeof navigator === 'undefined' || !navigator.mediaDevices?.getDisplayMedia) {\n      const error = new Error('getDisplayMedia not available (SSR or unsupported browser)');\n      errors.value.push(error);\n      onError?.(error);\n      throw error;\n    }\n\n    shareState.value = 'requesting';\n\n    try {\n      \n      const mergedOptions: ScreenShareOptions = {\n        ...defaultOptions,\n        ...options,\n      };\n\n      \n      const constraints: DisplayMediaStreamOptions = {\n        video: mergedOptions.video ?? true,\n        audio: mergedOptions.audio ?? false,\n      };\n\n      \n      if (mergedOptions.preferCurrentTab !== undefined) {\n        (constraints as any).preferCurrentTab = mergedOptions.preferCurrentTab;\n      }\n      if (mergedOptions.surfaceSwitching !== undefined) {\n        (constraints as any).surfaceSwitching = mergedOptions.surfaceSwitching;\n      }\n      if (mergedOptions.selfBrowserSurface !== undefined) {\n        (constraints as any).selfBrowserSurface = mergedOptions.selfBrowserSurface;\n      }\n      \n      if (mergedOptions.systemAudio !== undefined) {\n        (constraints as any).systemAudio = mergedOptions.systemAudio;\n      } else if (mergedOptions.audio) {\n        \n        (constraints as any).systemAudio = 'include';\n      }\n\n      const stream = await navigator.mediaDevices.getDisplayMedia(constraints);\n\n      screenStream.value = stream;\n      shareState.value = 'active';\n\n      \n      detectShareType(stream);\n\n      \n      const videoTrack = stream.getVideoTracks()[0];\n      if (videoTrack) {\n        videoTrack.addEventListener('ended', handleStreamEnded);\n      }\n\n      onShareStarted?.(stream);\n      return stream;\n    } catch (error) {\n      shareState.value = 'error';\n      const err = error as Error;\n      errors.value.push(err);\n      onError?.(err);\n      throw error;\n    }\n  };\n\n  \n  const stopScreenShare: ScreenShareStopFn = () => {\n    if (screenStream.value) {\n      \n      const videoTrack = screenStream.value.getVideoTracks()[0];\n      if (videoTrack) {\n        videoTrack.removeEventListener('ended', handleStreamEnded);\n      }\n\n      \n      screenStream.value.getTracks().forEach((track) => track.stop());\n      screenStream.value = null;\n      shareState.value = 'idle';\n      shareType.value = null;\n      onShareStopped?.();\n    }\n  };\n\n  \n  onBeforeUnmount(() => {\n    stopScreenShare();\n  });\n\n  \n  return {\n    \n    screenStream,\n    \n    shareState,\n    \n    shareType,\n    \n    errors,\n    \n    isSharing,\n    \n    startScreenShare,\n    \n    stopScreenShare,\n  };\n}\n"
      }
    ]
  }
}